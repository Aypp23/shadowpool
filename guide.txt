# Step-by-Step Guide to Building on iExec

### **STEP 1 - The front end**

If you need a frontend where end user will protect a Data with DataProtector, you can bootstrap one from our starter page. Next.js, React, or Vue.js, it‚Äôs up to you. 

The DataProtector tool, which enables builders to protect managed data, is already included. Take some time to explore how it‚Äôs implemented and how it works.

- [Starter page](https://docs.iex.ec/get-started/quick-start)

https://github.com/iExecBlockchainComputing/iexec-nextjs-starter
https://github.com/iExecBlockchainComputing/iexec-react-starter
https://github.com/iExecBlockchainComputing/iexec-vuejs-starter

**OK,** your front-end is ready, you wanna now test it on Arbitrum Sepolia? Oh God, you need tokens, check our faucet link here to get some RLC needed for confidential computing tasks. Since you are on Arbitrum, you will need to bridge it from the Arbitrum bridge. 

- [iExec Faucet](https://explorer.iex.ec/arbitrum-mainnet/faucet)
- [Arbitrum Bridge](https://portal.arbitrum.io/bridge?sourceChain=sepolia&destinationChain=arbitrum-sepolia&tab=bridge&sanitized=true)

‚ö†Ô∏è **Things you need to keep in mind**

- You can check the Arbitrum Sepolia explorer [HERE](https://explorer.iex.ec/arbitrum-sepolia-testnet)
- if you don't want to use a starter, you can just install the Data Protector npm package in your project `npm install @iexec/dataprotector.` (you can check the code integration in our [Code SandBox](https://codesandbox.io/p/github/iExecBlockchainComputing/dataprotector-sandbox/main))
- If your project is not using protected data created by DataProtector, you can go directly to step two.
- Choose and declare the type of your protected data in your `protectData` function. This type must match the one expected by your iApp when retrieving the protected data for processing.
Everything you need to know about dataset types [here](https://docs.iex.ec/guides/manage-data/handle-schemas-dataset-types).

```jsx
// Simple Example
const dataSimple = {
email: dataToProtect,
};
```

- Since the Arbitrum deployment is early, you need to activate the experimental true in your DataProtector constructor instance.

```
 const dataProtector = new IExecDataProtector(provider, {
          allowExperimentalNetworks: true,
        });
```

### STEP 2 - IApp Building with iApp Generator

Okay, you've got a front-end now you need an iApp. 

You can quickly bootstrap a privacy-preserving application locally using the **IApp Generator**.

Install the package:
Check our documentation [here](https://docs.iex.ec/guides/build-iapp/deploy-&-run). 

```bash
npm install -g @iexec/iapp
```

Then, simply run:

```bash
iapp init
```

You can test you iApp before deploy it

```bash
iapp test
```

and you‚Äôre good to go!

You can **customize/build** your application however you like. Once you‚Äôre done, you can deploy it.

you can deploy your app with:

```bash
iapp deploy --chain arbitrum-sepolia-testnet
```

‚ö†Ô∏è **Things to keep in mind**

- Don‚Äôt forget to import your private key (with token) into the project if you want to be able to deploy your iApp.
- You can use the command:

```bash
iapp wallet import <your-private-key>
```

### Step 3: Manage Access of your protected data

You now have a frontend with DataProtector, capable of creating protected data, and an iExec application that can compute on this protected data.
The next step is to manage data access authorization using the `grantAccess` method.
This method allows you to authorize the iExec application you built to access the data, as well as to grant a user permission to use it.

‚ö†Ô∏è **Things to keep in mind**

- When you use DataProtector and the `grantAccess` method, orders are automatically deployed on the network.
However, if your project doesn‚Äôt use DataProtector or any protected data, you‚Äôll need to manually publish your order using the iExec low-level SDK, please check the step 3.1 below

### Step 3.1: Deploy orders for an iApp that doesn‚Äôt use protected data

If your project doesn‚Äôt use protected data but relies on other types of data such as secrets, API keys, or external data [(check possible input type)](https://docs.iex.ec/guides/build-iapp/inputs) you‚Äôll need to **publish an order** to make your iApp accessible and usable for your users.

[Please follow this documentation section.](https://docs.iex.ec/guides/use-iapp/run-iapp-without-ProtectedData) 

### Step 4: Run you iApp

**4.1 run your iApp with protected data.** 
Since DataProtector is managing everything for you, you don't need to interact with another SDK or low-level., Please follow this documentation below. 

https://docs.iex.ec/guides/use-iapp/run-iapp-with-ProtectedData

**4.2 run an iApp without protected data.** 

You can test and run your iApp directly in the CLI command tool, but for a smoother end-user experience, you need to integrate the interaction in your frontend using the SDK low-level. 

- To run an iApp without protected data, please use this doc [here](https://docs.iex.ec/guides/use-iapp/run-iapp-without-ProtectedData)
- iExec SDK low level for more granular control [here](https://github.com/iExecBlockchainComputing/iexec-sdk/blob/master/docs/README.md)

### Useful addresses you might need

```json
421614: {
    name: 'arbitrum-sepolia-testnet',
    prodWorkerpoolAddress: '0xB967057a21dc6A66A29721d96b8Aa7454B7c383F',
    dataProtectorSubgraph:
      'https://thegraph.arbitrum-sepolia-testnet.iex.ec/api/subgraphs/id/5YjRPLtjS6GH6bB4yY55Qg4HzwtRGQ8TaHtGf9UBWWd',
    ipfsGateway: 'https://ipfs-gateway.arbitrum-sepolia-testnet.iex.ec',
    ipfsUploadUrl: 'https://ipfs-upload.arbitrum-sepolia-testnet.iex.ec',
    isExperimental: true,
  },
  42161: {
    name: 'arbitrum-mainnet',
    prodWorkerpoolAddress: '0x2C06263943180Cc024dAFfeEe15612DB6e5fD248',
    dataProtectorSubgraph:
      'https://thegraph.arbitrum.iex.ec/api/subgraphs/id/Ep5zs5zVr4tDiVuQJepUu51e5eWYJpka624X4DMBxe3u',
    ipfsGateway: 'https://ipfs-gateway.arbitrum-mainnet.iex.ec',
    ipfsUploadUrl: 'https://ipfs-upload.arbitrum-mainnet.iex.ec',
  },
```

Handle Schemas and Dataset Types [‚Äã](#handle-schemas-and-dataset-types)
=======================================================================

**Schemas are like content labels that describe what's inside your protected data.**

They define the structure and types of your data automatically when you protect it, making it easy for iApp to know what they're working with.

Think of schemas as **data fingerprints** - they tell iApp "this protected data contains an email address and a phone number" without revealing the actual values.

Use the [iExec explorer](https://explorer.iex.ec/arbitrum-mainnet/datasets) to browse protected data and see their asset types. Make filtered searches based on schema to find data that fits your needs.

How schemas work [‚Äã](#how-schemas-work)
---------------------------------------

When you protect data with DataProtector, the SDK automatically analyzes your JSON object and generates a schema. **No manual schema definition needed** - it's all handled for you.

ts

    const protectedData = await dataProtectorCore.protectData({
      name: 'User Contact',
      data: {
        email: 'alice@example.com',
        phoneNumber: '+1234567890',
        preferences: {
          newsletter: true,
          notifications: false,
        },
      },
    });
    
    console.log('‚úÖ Protected data created!');
    console.log('üìç Address:', protectedData.address);

**üè∑Ô∏è Generated Schema:**

json

    {
      "email": "string",
      "phoneNumber": "string",
      "preferences": {
        "newsletter": "bool",
        "notifications": "bool"
      }
    }

Schema Structure

The schema automatically maps your data structure to types that iApp can understand and validate.

Supported data types [‚Äã](#supported-data-types)
-----------------------------------------------

The schema automatically detects these types:

Type

Description

Example

`string`

Text data

`"alice@example.com"`

`bool`

Boolean values

`true`, `false`

`f64`

Numbers

`42`, `3.14`

`i128`

Big integers

`BigInt(123456789)`

`application/octet-stream`

Binary data

File contents

`image/jpeg`, `image/png`, etc.

Media files

Images, videos

Auto-Detection

The SDK automatically detects file types based on content. No need to specify MIME types manually.

Why schemas matter [‚Äã](#why-schemas-matter)
-------------------------------------------

*   **Clarity**: Makes your data easier to understand and reuse
*   **Safety**: Ensures iExec apps don‚Äôt process the wrong data
*   **Structure**: Facilitates structured communication between **front-end and iApp logic**

### **For iApp Development** [‚Äã](#for-iapp-development)

Schemas let your iApp validate and process data safely:

ts

    // Inside your iApp
    const email = await deserializer.getValue('email', 'string');
    const preferences = await deserializer.getValue(
      'preferences.newsletter',
      'bool'
    );

### **For Type Safety** [‚Äã](#for-type-safety)

Prevents your iApp from processing incompatible data types.

### **For Data Discovery** [‚Äã](#for-data-discovery)

Users can find relevant protected data without seeing the actual content:

ts

    const listProtectedData = await dataProtectorCore.getProtectedData({
      requiredSchema: {
        email: 'string',
      },
    });

Real examples [‚Äã](#real-examples)
---------------------------------

For real-world applications built by developers using various asset types, check out the [iExec case studies](https://www.iex.ec/case-studies) to see how schemas are used in production environments.

### Simple User Profile [‚Äã](#simple-user-profile)

ts

    const userData = await dataProtectorCore.protectData({
      data: {
        email: 'user@example.com',
        age: 25,
        isSubscribed: true,
      },
    });

**üè∑Ô∏è Generated Schema:**

json

    {
      "email": "string",
      "age": "f64",
      "isSubscribed": "bool"
    }

### Nested Contact Information [‚Äã](#nested-contact-information)

ts

    const contactData = await dataProtectorCore.protectData({
      data: {
        personal: {
          firstName: 'Alice',
          lastName: 'Smith',
        },
        contact: {
          email: 'alice@example.com',
          phone: '+1234567890',
        },
        preferences: {
          marketing: false,
          notifications: true,
        },
      },
    });

**üè∑Ô∏è Generated Schema:**

json

    {
      "personal": {
        "firstName": "string",
        "lastName": "string"
      },
      "contact": {
        "email": "string",
        "phone": "string"
      },
      "preferences": {
        "marketing": "bool",
        "notifications": "bool"
      }
    }

### File Data [‚Äã](#file-data)

ts

    const fileBuffer = await createArrayBufferFromFile(file);
    
    const fileData = await dataProtectorCore.protectData({
      data: {
        fileName: file.name,
        fileContent: fileBuffer,
        uploadDate: Date.now(),
      },
    });

**üè∑Ô∏è Schema for file upload:**

json

    {
      "fileName": "string",
      "fileContent": "image/jpeg",
      "uploadDate": "f64"
    }

Using schemas in iApp [‚Äã](#using-schemas-in-iapp)
-------------------------------------------------

Once you have protected data with a schema, you'll want to process it inside an iApp.

Type Matching

**Your iApp and frontend must use the same field names and types.** If they don't match, you'll get runtime errors when processing the data.

‚Üí **Ready to build an iApp?** Check out our detailed [Inputs guide](/guides/build-iapp/inputs) to learn how to access schema fields inside your iApp using the deserializer.

Next steps [‚Äã](#next-steps)
---------------------------

**You now understand how schemas work with protected data.** Here's what to explore next:

*   **Build an iApp**: Check out the [iApp Generator guide](/references/iapp-generator) to create your first data processor
*   **Process data**: Learn about [processProtectedData](/references/dataProtector/methods/processProtectedData) for running computations
*   **See it in action**: Try our [Hello World tutorial](/get-started/helloWorld) for a complete example
Deploy and Run an iApp [‚Äã](#deploy-and-run-an-iapp)
===================================================

It's time to run your iApp! After building and testing, you'll need to deploy it to a supported network and then execute it.

Prerequisites [‚Äã](#prerequisites)
---------------------------------

Before deploying and running your iApp, ensure you have sufficient RLC tokens to cover:

*   **Workerpool execution costs** for running your iApp on decentralized compute resources
*   **Protected Data access fees** if your iApp requires confidential datasets (and you're not the data provider)
*   **iApp execution costs** if you're not the owner of the iApp you're running

**Getting RLC tokens:**

*   **Arbitrum Mainnet**: Purchase RLC from [exchanges](/get-started/overview/rlc) or bridge from Ethereum using the [RLC Bridge](/get-started/tooling-and-explorers/bridge)
*   **Arbitrum Sepolia Testnet**: Get free RLC tokens from the [iExec RLC Faucet](https://explorer.iex.ec/arbitrum-sepolia-testnet/faucet) for testing purposes
*   **Bellecour**: Bridge RLC from Ethereum using the [RLC Bridge](/get-started/tooling-and-explorers/bridge)

Deploy your iApp [‚Äã](#deploy-your-iapp)
---------------------------------------

After your tests pass and the package is built, you can deploy your iApp to a supported network. During deployment, you'll enter your DockerHub credentials, specify your app version, and push both standard and TEE-compatible images:

Terminal

$ iapp deploy

Now that your iApp has been deployed on the iExec protocol, you can navigate to the `cache` folder to see your deployments saved. A file named `deployments.json` in the folder corresponding to your target network will be created containing each deployment made on this network. These files will help you easily track each deployment per network.

Here is an example:

json

    [
      {
        "sconifiedImage": "robiniexec/iapp:0.0.1-tee-scone-5.9.1-v16-5aea8b4aa71d",
        "appContractAddress": "0x9665136c599ec361C8eE627eC4F35A23fBa94897",
        "owner": "0xbabE8270aC9857Af3aaC06877888F1939FbeC578",
        "date": "2025-08-12T13:16:18.252Z"
      },
      ...
    ]

Run your iApp [‚Äã](#run-your-iapp)
---------------------------------

There are multiple ways to execute an iApp on the iExec network. An iApp can be:

*   **Self-sufficient** - Basic execution without additional inputs
*   **Data-dependent** - Requires protected data, secrets, input files, or command-line arguments

The iApp Generator CLI provides a streamlined way to execute iApp, especially for developers who have built their own iApp.

> **Note**: For installation instructions, see the [iApp Generator Getting Started guide](/references/iapp-generator/getting-started).

Terminal

$ iapp run 0x1f80DCebc2EAAff0Db7156413C43B7e88D189923

Now that you have run your iApp on the iExec protocol, you can navigate to the `cache` folder to see your runs saved. A file named `runs.json` in the folder corresponding to your target network will be created containing each run made on this network. These files will help you easily track each run per network. Use the [iExec Explorer](/get-started/tooling-and-explorers/iexec-explorer) to retrieve more data about your tasks.

Here is an example:

json

    [
      {
        "iAppAddress": "0x9665136c599ec361C8eE627eC4F35A23fBa94897",
        "dealid": "0x26d758de1be51697c33fa606cd0c5243082a6e675a4463b106d71fde2893280f",
        "taskid": "0x1a58dd6018b30b022eb35be53ad9374eb630925458d14643a1dfd9c686b964d8",
        "txHash": "0x6f14eac6933c609fb6d3e6b2bbd18c373c6dc99c7d7fd22036d5a20f847c5e42",
        "date": "2025-08-18T18:30:03.711Z"
      },
      ...
    ]

Next Steps [‚Äã](#next-steps)
---------------------------

*   Learn how to [manage access to your iApp](/guides/build-iapp/manage-access)
*   Discover [debugging techniques](/guides/build-iapp/debugging) for troubleshooting

Manage Access [‚Äã](#manage-access)
=================================

**Orders control who can use your iApp and under what conditions.** Once your iApp is deployed with iApp Generator, you need to publish app orders to make it accessible to users and define your governance rules.

Think of orders as **usage proposals** - they define pricing, access restrictions, and execution conditions for your app.

What is an Order? [‚Äã](#what-is-an-order)
----------------------------------------

An **app order** is a signed proposal that defines the usage conditions for your iApp:

*   **Price per execution** (in nRLC)
*   **Number of authorized uses**
*   **Access restrictions** (specific users, workerpools)
*   **TEE configuration** (for confidential applications)

TIP

Currently, order management is not yet available in iApp Generator. This guide shows you how to use the iExec SDK CLI to create and manage your app orders.

For complete SDK documentation, check the [iExec SDK documentation](/references/sdk).

How Orders Work [‚Äã](#how-orders-work)
-------------------------------------

Here's the simplified process:

1.  **You create an app order** with your conditions (price, restrictions, etc.)
2.  **You sign the order** with your wallet
3.  **You publish the order** on the iExec marketplace
4.  **Users can discover** and execute your iApp according to your conditions
5.  **You automatically receive** payment in RLC for each execution

    Deployed iApp + Published Signed App Order = Application accessible on iExec

App Order Example [‚Äã](#app-order-example)
-----------------------------------------

Here's an example app order for a sentiment analysis iApp:

json

    {
      "app": "0x123abc...", // Your iApp address
      "appprice": "1000000000", // 1 RLC per execution
      "volume": "100", // 100 authorized uses
      "tag": "0x0000000000000000000000000000000000000000000000000000000000000003", // TEE required
      "datasetrestrict": "0x0000000000000000000000000000000000000000",
      "workerpoolrestrict": "0x0000000000000000000000000000000000000000",
      "requesterrestrict": "0x0000000000000000000000000000000000000000"
    }

Creating an App Order [‚Äã](#creating-an-app-order)
-------------------------------------------------

### Step 1: Install the iExec SDK [‚Äã](#step-1-install-the-iexec-sdk)

Since iApp Generator doesn't handle orders yet, you need to use the iExec SDK CLI. For detailed installation instructions, see the [iExec SDK documentation](/references/sdk).

npmyarnpnpmbun

sh

    npm install iexec

sh

    yarn add iexec

sh

    pnpm add iexec

sh

    bun add iexec

Verify the installation:

bash

    iexec --version
    iexec --help

### Step 2: Configure your iExec Project [‚Äã](#step-2-configure-your-iexec-project)

In your iApp Generator project folder, initialize the iExec configuration:

bash

    # In your iApp Generator project folder
    iexec init --skip-wallet

This creates the necessary configuration files:

*   `iexec.json` - Project configuration
*   `chain.json` - Blockchain configuration

### Step 3: Configure your Wallet [‚Äã](#step-3-configure-your-wallet)

If you don't have an iExec wallet yet:

bash

    iexec wallet create

Or import an existing wallet:

bash

    iexec wallet import <private-key>

iApp Generator Users

If you used iApp Generator, you already have an `iapp.config.json` file with a generated private key. You can use this existing private key to initialize your wallet:

bash

    # Extract the private key from your `iapp.config.json`
    iexec wallet import <your-private-key>

Check your wallet:

bash

    iexec wallet show

### Step 4: Create the App Order [‚Äã](#step-4-create-the-app-order)

Initialize the app order:

bash

    iexec order init --app

This adds an `apporder` section to your `iexec.json`. Edit the parameters according to your needs:

json

    {
      "apporder": {
        "app": "0xYourAppAddress",
        "appprice": "1000000000",
        "volume": "100",
        "tag": "0x0000000000000000000000000000000000000000000000000000000000000003",
        "datasetrestrict": "0x0000000000000000000000000000000000000000",
        "workerpoolrestrict": "0x0000000000000000000000000000000000000000",
        "requesterrestrict": "0x0000000000000000000000000000000000000000"
      }
    }

### Step 5: Sign and Publish the Order [‚Äã](#step-5-sign-and-publish-the-order)

Sign your app order with your wallet:

bash

    iexec order sign --app

Publish the order on the marketplace:

bash

    iexec order publish --app

Your iApp is now accessible according to the conditions you defined!

Managing orders [‚Äã](#managing-orders)
-------------------------------------

### View published orders [‚Äã](#view-published-orders)

Check active orders for your app:

bash

    iexec orderbook app <your-app-address>

### Modify an Order [‚Äã](#modify-an-order)

To change conditions, create a new order with new parameters.

### Cancel an Order [‚Äã](#cancel-an-order)

Remove an order from the marketplace:

bash

    iexec order unpublish --app <orderHash>

Completely invalidate an order:

bash

    iexec order cancel --app <orderHash>

### **Confidential App (TEE Required)** [‚Äã](#confidential-app-tee-required)

json

    {
      "appprice": "2000000000",
      "volume": "500",
      "tag": "0x0000000000000000000000000000000000000000000000000000000000000003"
    }

App order parameters [‚Äã](#app-order-parameters)
-----------------------------------------------

Here's the detailed description of each parameter:

### `app` required [‚Äã](#app)

**Description:** Ethereum address of your deployed iApp

**Example:** `"0x123abc456def..."`

### `appprice` optional [‚Äã](#appprice)

**Description:** Price to charge per execution (in nano RLC - nRLC)

**Common values:**

*   `"0"` - Free
*   `"1000000000"` - 1 RLC per execution
*   `"500000000"` - 0.5 RLC per execution

TIP

1 RLC = 1,000,000,000 nano RLC (10^9)

### `volume` optional [‚Äã](#volume)

**Description:** Number of authorized executions (decrements with each use)

**Examples:**

*   `1` - Single use
*   `100` - Limited campaign
*   `10000` - Virtually unlimited usage

### `tag` optional [‚Äã](#tag)

**Description:** Specifies the required execution environment

**Supported values:**

Value

Description

`0x0000000000000000000000000000000000000000000000000000000000000000`

Standard execution

`0x0000000000000000000000000000000000000000000000000000000000000003`

TEE required (Scone)

### Access restrictions [‚Äã](#access-restrictions)

All restrictions use `0x0000000000000000000000000000000000000000` to indicate "no restriction".

#### `datasetrestrict` optional [‚Äã](#datasetrestrict)

**Description:** Restrict usage to a specific dataset

**Typical usage:** `0x0000000000000000000000000000000000000000` (no restriction)

#### `workerpoolrestrict` optional [‚Äã](#workerpoolrestrict)

**Description:** Restrict execution to a specific workerpool

**Example:** `prod-v8-bellecour.main.pools.iexec.eth` for the main workerpool

#### `requesterrestrict` optional [‚Äã](#requesterrestrict)

**Description:** Restrict usage to a specific user

**Typical usage:** `0x0000000000000000000000000000000000000000` (open to all)

What's Next? [‚Äã](#what-s-next)
------------------------------

**Your iApp is now accessible with custom conditions!**

Next steps:

*   **Monitor executions**: Track usage with `iexec task show`
*   **Adjust pricing**: Create new orders based on demand
*   **Manage revenue**: Check your earnings with `iexec account show`

### Technical deep dive [‚Äã](#technical-deep-dive)

*   **[iExec SDK Documentation](/references/sdk)** - Complete CLI reference

How to Pay for iApp Executions [‚Äã](#how-to-pay-for-iapp-executions)
===================================================================

iExec uses RLC tokens as the native currency for executing iApps. This guide covers how to acquire RLC, stake it on the protocol, and manage execution costs.

Getting RLC Tokens [‚Äã](#getting-rlc-tokens)
-------------------------------------------

To execute iApps, you need RLC tokens in your wallet. For detailed information on how to obtain RLC tokens, see our [RLC guide](/get-started/overview/rlc).

Staking RLC [‚Äã](#staking-rlc)
-----------------------------

RLC tokens need to be staked on the iExec protocol to allow task payment. Use the [iExec SDK](/references/sdk) to deposit and manage your RLC:

ts

    // Check your balance
    const balance = await iexec.account.checkBalance('0xa0c15e...');
    console.log('Nano RLC staked:', balance.stake.toString());
    console.log('Nano RLC locked:', balance.locked.toString());
    
    // Lock RLC in your account in the iExec protocol
    await iexec.account.deposit(1_000_000_000); // Deposit 1 RLC

Now you are ready to run a task on the iExec Protocol and pay for it. See our guide on [running iApp with ProtectedData](/guides/use-iapp/run-iapp-with-ProtectedData) for detailed execution steps.

Understanding Pricing [‚Äã](#understanding-pricing)
-------------------------------------------------

### Cost components [‚Äã](#cost-components)

iApp execution costs consist of several components:

1.  **Application Fee**: Paid to the app developer
2.  **Data Fee**: Paid to the data owner (if using protected data)
3.  **Workerpool Fee**: Paid to the computation provider
4.  **Gas Fees**: Blockchain transaction costs

### Setting maximum prices [‚Äã](#setting-maximum-prices)

You can control costs by setting maximum prices for each component:

ts

    const result = await dataProtectorCore.processProtectedData({
      protectedData: '0x123abc...',
      app: '0x456def...',
      dataMaxPrice: 5, // Maximum amount (in nRLC) to pay the protected data owner
      appMaxPrice: 3, // Maximum amount (in nRLC) to pay the iApp provider
      workerpoolMaxPrice: 2, // Maximum amount (in nRLC) to pay the workerpool provider
    });

INFO

All price parameters are in nRLC (nano RLC). The default value for all price parameters is 0, which means only free resources are accepted.

Next Steps [‚Äã](#next-steps)
---------------------------

Now that you know how to pay for iApp executions:

*   [Run iApp with ProtectedData](/guides/use-iapp/run-iapp-with-ProtectedData)
*   [Run iApp without ProtectedData](/guides/use-iapp/run-iapp-without-ProtectedData)

Run iApp with a ProtectedData [‚Äã](#run-iapp-with-a-protecteddata)
=================================================================

When running an iApp, you can use multiple types of inputs. While ProtectedData is not mandatory to run an iApp, it's a powerful input type that allows you to process encrypted data from another provider. You can also use non-persistent inputs that come directly from you (the requester) and can change between each execution: Arguments, Input Files, and Secrets. These non-persistent inputs are perfect for customizing the iApp's behavior for each specific run.

Prerequisites [‚Äã](#prerequisites)
---------------------------------

First, install DataProtector in your project (for more details see [DataProtector Getting Started](/references/dataProtector/getting-started)):

npmyarnpnpmbun

bash

    npm install @iexec/dataprotector

bash

    yarn add @iexec/dataprotector

bash

    pnpm add @iexec/dataprotector

bash

    bun add @iexec/dataprotector

Adding Protected Data [‚Äã](#adding-protected-data)
-------------------------------------------------

When working with protected data that contains multiple files, you can specify which file to process.

ts

    // Process protected data with specific path
    const result = await dataProtectorCore.processProtectedData({
      protectedData: '0x123abc...',
      app: '0x456def...',
      path: 'data/input.csv',
    });

The `processProtectedData` function will automatically download and decrypt the results for you. Nevertheless, if you want to retrieve results from a completed task, you can do so as follows:

ts

    // Retrieve the result
    const taskResult = await dataProtectorCore.getResultFromCompletedTask({
      taskId: taskId,
    });

Adding Command-Line Arguments [‚Äã](#adding-command-line-arguments)
-----------------------------------------------------------------

Command-line arguments are passed as a string to the iApp and are visible on the blockchain.

ts

    // Process protected data with arguments
    const result = await dataProtectorCore.processProtectedData({
      protectedData: '0x123abc...',
      app: '0x456def...',
      args: '--input-path data/input.csv --output-format json --verbose',
    });

Adding Input Files [‚Äã](#adding-input-files)
-------------------------------------------

Input files are URLs to public files that the iApp can download during execution.

ts

    // Process protected data with input files
    const result = await dataProtectorCore.processProtectedData({
      protectedData: '0x123abc...',
      app: '0x456def...',
      inputFiles: [
        'https://raw.githubusercontent.com/user/repo/main/config.json',
        'https://example.com/public-data.csv',
      ],
    });

Adding Secrets [‚Äã](#adding-secrets)
-----------------------------------

Secrets are sensitive data like API keys, passwords, or tokens that are stored securely and made available to the iApp as environment variables.

ts

    // Process protected data with secrets
    const result = await dataProtectorCore.processProtectedData({
      protectedData: '0x123abc...',
      app: '0x456def...',
      secrets: {
        1: 'openai-api-key',
        2: 'database-password',
      },
    });

    Run iApp without a ProtectedData [‚Äã](#run-iapp-without-a-protecteddata)
=======================================================================

When running an iApp, you can use multiple types of inputs even without ProtectedData. Non-persistent inputs come directly from you (the requester) and can change between each execution, making them perfect for customizing the iApp's behavior for each specific run. These inputs include Arguments, Input Files, and Secrets, which allow you to provide additional data, parameters, and configuration to enable processing and customize functionality.

Prerequisites [‚Äã](#prerequisites)
---------------------------------

First, install iExec SDK in your project (for more details see [iExec SDK documentation](/references/sdk)):

npmyarnpnpmbun

sh

    npm install iexec

sh

    yarn add iexec

sh

    pnpm add iexec

sh

    bun add iexec

Adding Command-Line Arguments [‚Äã](#adding-command-line-arguments)
-----------------------------------------------------------------

Command-line arguments are passed as a string to the iApp and are visible on the blockchain.

ts

    // Basic arguments
    const requestorderToSign = await iexec.order.createRequestorder({
      app: '0x456def...',
      category: 0,
      appmaxprice: 10,
      workerpool: '0xa5de76...',
      params: 'arg1 arg2 arg3', // Command-line arguments
      // Other parameters have default values
    });
    const requestOrder = await iexec.order.signRequestorder(requestorderToSign);
    
    // Fetch app orders
    const appOrders = await iexec.orderbook.fetchAppOrderbook(
      '0x456def...' // Filter by specific app
    );
    if (appOrders.orders.length === 0) {
      throw new Error('No app orders found for the specified app');
    }
    
    // Fetch workerpool orders
    const workerpoolOrders = await iexec.orderbook.fetchWorkerpoolOrderbook({
      workerpool: '0xa5de76...', // Filter by specific workerpool
    });
    if (workerpoolOrders.orders.length === 0) {
      throw new Error('No workerpool orders found for the specified workerpool');
    }
    
    // Execute the task
    const taskId = await iexec.order.matchOrders({
      requestorder: requestOrder,
      apporder: appOrders.orders[0].order,
      workerpoolorder: workerpoolOrders.orders[0].order,
    });

Adding Input Files [‚Äã](#adding-input-files)
-------------------------------------------

Input files are URLs to public files that the iApp can download during execution.

ts

    // Single input file
    const requestorderToSign = await iexec.order.createRequestorder({
      app: '0x456def...',
      category: 0, // Required: category for the request
      appmaxprice: 10,
      workerpool: '0xa5de76...',
      params: {
        iexec_input_files: [
          'https://example.com/config.json',
          'https://example.com/template.html',
          'https://example.com/data.csv',
        ],
      },
    });
    const requestOrder = await iexec.order.signRequestorder(requestorderToSign);
    
    // Fetch app orders
    const appOrders = await iexec.orderbook.fetchAppOrderbook(
      '0x456def...' // Filter by specific app
    );
    if (appOrders.orders.length === 0) {
      throw new Error('No app orders found for the specified app');
    }
    
    // Fetch workerpool orders
    const workerpoolOrders = await iexec.orderbook.fetchWorkerpoolOrderbook({
      workerpool: '0xa5de76...', // Filter by specific workerpool
    });
    if (workerpoolOrders.orders.length === 0) {
      throw new Error('No workerpool orders found for the specified workerpool');
    }
    
    // Execute the task
    const taskId = await iexec.order.matchOrders({
      requestorder: requestOrder,
      apporder: appOrders.orders[0].order,
      workerpoolorder: workerpoolOrders.orders[0].order,
    });

Adding Secrets [‚Äã](#adding-secrets)
-----------------------------------

Secrets are sensitive data like API keys, passwords, or tokens that are stored securely and made available to the iApp as environment variables.

Browser

ts

    // Basic secrets
    const requestorderToSign = await iexec.order.createRequestorder({
      app: '0x456def...',
      category: 0, // Required: category for the request
      appmaxprice: 10,
      workerpool: '0xa5de76...',
      params: {
        iexec_secrets: {
          1: 'api-key-12345',
          2: 'database-password',
        },
      },
    });
    const requestOrder = await iexec.order.signRequestorder(requestorderToSign);
    
    // Fetch app orders
    const appOrders = await iexec.orderbook.fetchAppOrderbook(
      '0x456def...' // Filter by specific app
    );
    if (appOrders.orders.length === 0) {
      throw new Error('No app orders found for the specified app');
    }
    
    // Fetch workerpool orders
    const workerpoolOrders = await iexec.orderbook.fetchWorkerpoolOrderbook({
      workerpool: '0xa5de76...', // Filter by specific workerpool
    });
    if (workerpoolOrders.orders.length === 0) {
      throw new Error('No workerpool orders found for the specified workerpool');
    }
    
    // Execute the task
    const taskId = await iexec.order.matchOrders({
      requestorder: requestOrder,
      apporder: appOrders.orders[0].order,
      workerpoolorder: workerpoolOrders.orders[0].order,
    });

    
