Manage Access [â€‹](#manage-access)
=================================

**Want to keep your data private while still using it in confidential applications?**

DataProtector lets you encrypt data and control access through orders - specifying who can use it, how many times, and at what price. Protected data is only accessible in secure enclaves (TEEs) by authorized users and iApp.

Prerequisites [â€‹](#prerequisites)
---------------------------------

First, install DataProtector in your project (for more details see [DataProtector Getting Started](/references/dataProtector/getting-started)):

npmyarnpnpmbun

bash

    npm install @iexec/dataprotector

bash

    yarn add @iexec/dataprotector

bash

    pnpm add @iexec/dataprotector

bash

    bun add @iexec/dataprotector

Protect your Data [â€‹](#protect-your-data)
-----------------------------------------

**Here's what happens:** Your data gets encrypted client-side and stored as an NFT. Only you control who can decrypt and use it.

ts

    const protectedData = await dataProtectorCore.protectData({
      name: 'My Email Contact',
      data: {
        email: 'alice@example.com',
        firstName: 'Alice',
        lastName: 'Smith',
      },
    });
    
    console.log('Protected data address:', protectedData.address);

### What you Can Protect [â€‹](#what-you-can-protect)

**Data**: Any kind of data you want to keep private and make available for computations by authorized users and iApp.

**Supported types**: Common data types like text, numbers, true/false values, and files. See the [full list here](/references/dataProtector/types).

**Storage**: Store your data on IPFS or Arweave. For larger files, you can use your own IPFS node.

TIP

Need Help ? Check our [Schema and Dataset Types guide](/guides/manage-data/handle-schemas-dataset-types) for detailed formatting instructions.

Grant access [â€‹](#grant-access)
-------------------------------

By default, your protected data is private. To let others use it, you need to grant access to both:

*   An authorized user (who can trigger the processing)
*   An authorized iApp (the application that will process the data in the private environment)

This ensures that only specific users can use specific applications to process your data. Here's how to set it up:

ts

    
    const grantedAccess = await dataProtectorCore.grantAccess({
      protectedData: '0x123abc...', // Your protected data address
      authorizedApp: '0x456def...', // iApp that can process the data
      authorizedUser: '0x789cba...', // User who can trigger the processing
      pricePerAccess: 0, // Cost per use (in nRLC)
      numberOfAccess: 10, // Maximum number of uses
    });

### Parameters [â€‹](#parameters)

ts

    import { type GrantAccessParams } from '@iexec/dataprotector';

#### protectedData Required \* [â€‹](#protecteddata)

**Type:** `AddressOrENS`

The ethereum address of the protected data supplied by the user (returned when you created it). **You must own this data** to grant access.

#### authorizedApp Required \* [â€‹](#authorizedapp)

**Type:** `AddressOrENS`

**What it is**: The iApp address that's allowed to process your data inside the secure enclave.

**Why needed**: This ensures only specific, audited applications can access your data. No random code can touch it.

**Pro tip**: Use app whitelists for production. Instead of a single app address, you can specify a whitelist contract that contains multiple app versions. Very useful for when you need to upgrade your iApp, without losing all the granted access.

text

    // Single app
    authorizedApp: web3mail.apps.iexec.eth;
    
    // Or use a whitelist (recommended for production)
    authorizedApp: 0x781482C39CcE25546583EaC4957Fb7Bf04C277D2; // Web3Mail whitelist

#### authorizedUser Required \* [â€‹](#authorizeduser)

**Type:** `AddressOrENS`

**What it is**: The wallet address of the user that is allowed to process this data.

**Why needed**: Even with an authorized app, only specific users can trigger the computation. This gives you granular control over who uses your data.

**Don't forget**: Even if you are the owner of the data, you need to authorize yourself!

**Special case**: Set to `0x0000000000000000000000000000000000000000` to allow **any user** to trigger processing (useful for public datasets).

#### pricePerAccess Optional [â€‹](#priceperaccess)

**Type:** `number`  
**Default:** `0`

**Quick explanation**: How much you charge per data usage (in nano RLC - nRLC).

Set to `0` for free access, or specify a price to monetize your data automatically.

**Example**: `pricePerAccess: 1_000_000_000` = 1 RLC per access

â†’ **Want to learn more monetization capabilities?** See our detailed [Monetize Protected Data guide](/guides/manage-data/monetize-protected-data)

#### numberOfAccess Optional [â€‹](#numberofaccess)

**Quick explanation**: Maximum number of times this authorization can be used.

WARNING

Important If someone tries to process your data more times than allowed, they'll get a "no dataset orders" error. Set this high enough for your use case.

**Example values**:

*   `1` - Single use (great for one-time data analysis)
*   `100` - Limited campaign (email marketing with usage cap)
*   `10000` - Effectively unlimited for most use cases

What's Next? [â€‹](#what-s-next)
------------------------------

**You now have protected data with controlled access.** Here are your next steps:

*   **Process the data**: Use [processProtectedData](/references/dataProtector/methods/processProtectedData) to run computations
*   **Manage access**: [Revoke](/references/dataProtector/methods/revokeOneAccess) or [modify permissions](/references/dataProtector/methods/grantAccess) anytime
*   **Learn data types**: Deep dive into [schemas and dataset types](/guides/manage-data/handle-schemas-dataset-types)
*   **Monetize data**: Explore [data monetization strategies](/guides/manage-data/monetize-protected-data)

Handle Schemas and Dataset Types [â€‹](#handle-schemas-and-dataset-types)
=======================================================================

**Schemas are like content labels that describe what's inside your protected data.**

They define the structure and types of your data automatically when you protect it, making it easy for iApp to know what they're working with.

Think of schemas as **data fingerprints** - they tell iApp "this protected data contains an email address and a phone number" without revealing the actual values.

Use the [iExec explorer](https://explorer.iex.ec/bellecour/datasets) to browse protected data and see their asset types. Make filtered searches based on schema to find data that fits your needs.

How schemas work [â€‹](#how-schemas-work)
---------------------------------------

When you protect data with DataProtector, the SDK automatically analyzes your JSON object and generates a schema. **No manual schema definition needed** - it's all handled for you.

ts

    const protectedData = await dataProtectorCore.protectData({
      name: 'User Contact',
      data: {
        email: 'alice@example.com',
        phoneNumber: '+1234567890',
        preferences: {
          newsletter: true,
          notifications: false,
        },
      },
    });
    
    console.log('âœ… Protected data created!');
    console.log('ðŸ“ Address:', protectedData.address);

**ðŸ·ï¸ Generated Schema:**

json

    {
      "email": "string",
      "phoneNumber": "string",
      "preferences": {
        "newsletter": "bool",
        "notifications": "bool"
      }
    }

Schema Structure

The schema automatically maps your data structure to types that iApp can understand and validate.

Supported data types [â€‹](#supported-data-types)
-----------------------------------------------

The schema automatically detects these types:

Type

Description

Example

`string`

Text data

`"alice@example.com"`

`bool`

Boolean values

`true`, `false`

`f64`

Numbers

`42`, `3.14`

`i128`

Big integers

`BigInt(123456789)`

`application/octet-stream`

Binary data

File contents

`image/jpeg`, `image/png`, etc.

Media files

Images, videos

Auto-Detection

The SDK automatically detects file types based on content. No need to specify MIME types manually.

Why schemas matter [â€‹](#why-schemas-matter)
-------------------------------------------

*   **Clarity**: Makes your data easier to understand and reuse
*   **Safety**: Ensures iExec apps donâ€™t process the wrong data
*   **Structure**: Facilitates structured communication between **front-end and iApp logic**

### **For iApp Development** [â€‹](#for-iapp-development)

Schemas let your iApp validate and process data safely:

ts

    // Inside your iApp
    const email = await deserializer.getValue('email', 'string');
    const preferences = await deserializer.getValue(
      'preferences.newsletter',
      'bool'
    );

### **For Type Safety** [â€‹](#for-type-safety)

Prevents your iApp from processing incompatible data types.

### **For Data Discovery** [â€‹](#for-data-discovery)

Users can find relevant protected data without seeing the actual content:

ts

    const listProtectedData = await dataProtectorCore.getProtectedData({
      requiredSchema: {
        email: 'string',
      },
    });

Real examples [â€‹](#real-examples)
---------------------------------

For real-world applications built by developers using various asset types, check out the [iExec case studies](https://www.iex.ec/case-studies) to see how schemas are used in production environments.

### Simple User Profile [â€‹](#simple-user-profile)

ts

    const userData = await dataProtectorCore.protectData({
      data: {
        email: 'user@example.com',
        age: 25,
        isSubscribed: true,
      },
    });

**ðŸ·ï¸ Generated Schema:**

json

    {
      "email": "string",
      "age": "f64",
      "isSubscribed": "bool"
    }

### Nested Contact Information [â€‹](#nested-contact-information)

ts

    const contactData = await dataProtectorCore.protectData({
      data: {
        personal: {
          firstName: 'Alice',
          lastName: 'Smith',
        },
        contact: {
          email: 'alice@example.com',
          phone: '+1234567890',
        },
        preferences: {
          marketing: false,
          notifications: true,
        },
      },
    });

**ðŸ·ï¸ Generated Schema:**

json

    {
      "personal": {
        "firstName": "string",
        "lastName": "string"
      },
      "contact": {
        "email": "string",
        "phone": "string"
      },
      "preferences": {
        "marketing": "bool",
        "notifications": "bool"
      }
    }

### File Data [â€‹](#file-data)

ts

    const fileBuffer = await createArrayBufferFromFile(file);
    
    const fileData = await dataProtectorCore.protectData({
      data: {
        fileName: file.name,
        fileContent: fileBuffer,
        uploadDate: Date.now(),
      },
    });

**ðŸ·ï¸ Schema for file upload:**

json

    {
      "fileName": "string",
      "fileContent": "image/jpeg",
      "uploadDate": "f64"
    }

Using schemas in iApp [â€‹](#using-schemas-in-iapp)
-------------------------------------------------

Once you have protected data with a schema, you'll want to process it inside an iApp.

Type Matching

**Your iApp and frontend must use the same field names and types.** If they don't match, you'll get runtime errors when processing the data.

â†’ **Ready to build an iApp?** Check out our detailed [Inputs guide](/guides/build-iapp/inputs) to learn how to access schema fields inside your iApp using the deserializer.

Next steps [â€‹](#next-steps)
---------------------------

**You now understand how schemas work with protected data.** Here's what to explore next:

*   **Build an iApp**: Check out the [iApp Generator guide](/references/iapp-generator) to create your first data processor
*   **Process data**: Learn about [processProtectedData](/references/dataProtector/methods/processProtectedData) for running computations
*   **See it in action**: Try our [Hello World tutorial](/get-started/helloWorld) for a complete example

Monetize Protected Data [â€‹](#monetize-protected-data)
=====================================================

**Transform your encrypted data into a sustainable revenue stream.**

iExec DataProtector enables you to monetize your protected data through **signed orders** - a flexible system that lets you specify exact conditions for data access. Whether you're a data provider, researcher, or business owner, you can generate income from your valuable datasets while maintaining complete privacy and control.

**How it works**: You create and publish signed orders that define who can access your data, how much they pay per use, and how many times they can access it. Users pay automatically each time they process your data, giving you precise control over monetization.

Signed Orders (DataProtector Core) [â€‹](#signed-orders-dataprotector-core)
-------------------------------------------------------------------------

**How it works**: You create and publish signed orders that specify the exact conditions for accessing your protected data. Each order defines:

*   **Authorized App**: Which iApp can process your data
*   **Authorized User**: Who can access your data (specific address or any user)
*   **Price per Access**: Cost for each individual use
*   **Number of Access**: Maximum times the data can be used
*   **Usage Counting**: Each data processing decrements the available access count

ts

    // Create a signed order with specific conditions
    const grantedAccess = await dataProtectorCore.grantAccess({
      protectedData: '0x123abc...', // Your data address
      authorizedApp: 'email-processor.apps.iexec.eth', // Specific iApp only
      authorizedUser: '0x456def...', // Specific user only
      pricePerAccess: 5000000000, // 5 RLC per individual use
      numberOfAccess: 100, // Maximum 100 total uses
    });
    
    console.log('Signed order created:', grantedAccess);

**Perfect for**:

*   Direct partnerships with known clients
*   Precise control over access conditions
*   Simple setup with specific partners
*   Exact counting of data usage

Build and Test an iApp [â€‹](#build-and-test-an-iapp)
===================================================

iApp (iExec Applications) are decentralized applications that run on the iExec network. They use confidential computing to ensure data privacy and security while providing scalable off-chain computation.

About iApp Generator [â€‹](#about-iapp-generator)
-----------------------------------------------

Bootstrap TEE-compatible applications in minutes without any hardcoding skills, iApp Generator handles all the low-level complexity for you.

*   **Select your project mode & language** - Get started with either a basic or advanced setup, depending on your experience with the iExec framework. You can use Python or JavaScriptâ€”whichever you prefer!
*   **Develop your iApp effortlessly** - Write your application logic using familiar programming languages while the generator handles all TEE-specific configurations.
*   **Access to TEEs easily** - No need to dive into low-level requirements, create iApp that connect to TEEs in minutes.
*   **Check and deploy iApp quickly** - iApp Generator checks that your iApp complies with the iExec Framework and streamlines its deployment.

Prerequisites [â€‹](#prerequisites)
---------------------------------

First, install iApp Generator in your project (for more details see [iApp Generator Getting Started](/references/iapp-generator/getting-started)):

npmyarnpnpmbun

bash

    npm install -g @iexec/iapp-generator

bash

    yarn global add @iexec/iapp-generator

bash

    pnpm add -g @iexec/iapp-generator

bash

    bun add -g @iexec/iapp-generator

Quick Start [â€‹](#quick-start)
-----------------------------

Once installed, you can create and deploy your first iApp. The CLI will guide you through an interactive setup process to configure your project name, programming language, and template:

Terminal

$ iapp init

After the interactive setup, continue with development and deployment:

Development and Testing [â€‹](#development-and-testing)
-----------------------------------------------------

Navigate to your project and run tests locally to simulate the TEE environment. The CLI will build a Docker image, run your app, and show you the results:

Terminal

$ iapp test

Next Steps [â€‹](#next-steps)
---------------------------

*   When everything is ready [deploy and run your iApp](/guides/use-iapp/run-iapp-with-ProtectedData)

Deploy and Run an iApp [â€‹](#deploy-and-run-an-iapp)
===================================================

It's time to run your iApp! After building and testing, you'll need to deploy it to a supported network and then execute it.

Prerequisites [â€‹](#prerequisites)
---------------------------------

Before deploying and running your iApp, ensure you have sufficient RLC tokens to cover:

*   **Workerpool execution costs** for running your iApp on decentralized compute resources
*   **Protected Data access fees** if your iApp requires confidential datasets (and you're not the data provider)
*   **iApp execution costs** if you're not the owner of the iApp you're running

**Getting RLC tokens:**

*   **Arbitrum Mainnet**: Purchase RLC from [exchanges](/get-started/overview/rlc) or bridge from Ethereum using the [RLC Bridge](/get-started/tooling-and-explorers/bridge)
*   **Arbitrum Sepolia Testnet**: Get free RLC tokens from the [iExec RLC Faucet](https://explorer.iex.ec/arbitrum-sepolia-testnet/faucet) for testing purposes
*   **Bellecour**: Bridge RLC from Ethereum using the [RLC Bridge](/get-started/tooling-and-explorers/bridge)

Deploy your iApp [â€‹](#deploy-your-iapp)
---------------------------------------

After your tests pass and the package is built, you can deploy your iApp to a supported network. During deployment, you'll enter your DockerHub credentials, specify your app version, and push both standard and TEE-compatible images:

Terminal

$ iapp deploy

Now that your iApp has been deployed on the iExec protocol, you can navigate to the `cache` folder to see your deployments saved. A file named `deployments.json` in the folder corresponding to your target network will be created containing each deployment made on this network. These files will help you easily track each deployment per network.

Here is an example:

json

    [
      {
        "sconifiedImage": "robiniexec/iapp:0.0.1-tee-scone-5.9.1-v16-5aea8b4aa71d",
        "appContractAddress": "0x9665136c599ec361C8eE627eC4F35A23fBa94897",
        "owner": "0xbabE8270aC9857Af3aaC06877888F1939FbeC578",
        "date": "2025-08-12T13:16:18.252Z"
      },
      ...
    ]

Run your iApp [â€‹](#run-your-iapp)
---------------------------------

There are multiple ways to execute an iApp on the iExec network. An iApp can be:

*   **Self-sufficient** - Basic execution without additional inputs
*   **Data-dependent** - Requires protected data, secrets, input files, or command-line arguments

The iApp Generator CLI provides a streamlined way to execute iApp, especially for developers who have built their own iApp.

> **Note**: For installation instructions, see the [iApp Generator Getting Started guide](/references/iapp-generator/getting-started).

Terminal

$ iapp run 0x1f80DCebc2EAAff0Db7156413C43B7e88D189923

Now that you have run your iApp on the iExec protocol, you can navigate to the `cache` folder to see your runs saved. A file named `runs.json` in the folder corresponding to your target network will be created containing each run made on this network. These files will help you easily track each run per network. Use the [iExec Explorer](/get-started/tooling-and-explorers/iexec-explorer) to retrieve more data about your tasks.

Here is an example:

json

    [
      {
        "iAppAddress": "0x9665136c599ec361C8eE627eC4F35A23fBa94897",
        "dealid": "0x26d758de1be51697c33fa606cd0c5243082a6e675a4463b106d71fde2893280f",
        "taskid": "0x1a58dd6018b30b022eb35be53ad9374eb630925458d14643a1dfd9c686b964d8",
        "txHash": "0x6f14eac6933c609fb6d3e6b2bbd18c373c6dc99c7d7fd22036d5a20f847c5e42",
        "date": "2025-08-18T18:30:03.711Z"
      },
      ...
    ]

Next Steps [â€‹](#next-steps)
---------------------------

*   Learn how to [manage access to your iApp](/guides/build-iapp/manage-access)
*   Discover [debugging techniques](/guides/build-iapp/debugging) for troubleshooting

Manage Access [â€‹](#manage-access)
=================================

**Orders control who can use your iApp and under what conditions.** Once your iApp is deployed with iApp Generator, you need to publish app orders to make it accessible to users and define your governance rules.

Think of orders as **usage proposals** - they define pricing, access restrictions, and execution conditions for your app.

What is an Order? [â€‹](#what-is-an-order)
----------------------------------------

An **app order** is a signed proposal that defines the usage conditions for your iApp:

*   **Price per execution** (in nRLC)
*   **Number of authorized uses**
*   **Access restrictions** (specific users, workerpools)
*   **TEE configuration** (for confidential applications)

TIP

Currently, order management is not yet available in iApp Generator. This guide shows you how to use the iExec SDK CLI to create and manage your app orders.

For complete SDK documentation, check the [iExec SDK documentation](/references/sdk).

How Orders Work [â€‹](#how-orders-work)
-------------------------------------

Here's the simplified process:

1.  **You create an app order** with your conditions (price, restrictions, etc.)
2.  **You sign the order** with your wallet
3.  **You publish the order** on the iExec marketplace
4.  **Users can discover** and execute your iApp according to your conditions
5.  **You automatically receive** payment in RLC for each execution

    Deployed iApp + Published Signed App Order = Application accessible on iExec

App Order Example [â€‹](#app-order-example)
-----------------------------------------

Here's an example app order for a sentiment analysis iApp:

json

    {
      "app": "0x123abc...", // Your iApp address
      "appprice": "1000000000", // 1 RLC per execution
      "volume": "100", // 100 authorized uses
      "tag": "0x0000000000000000000000000000000000000000000000000000000000000003", // TEE required
      "datasetrestrict": "0x0000000000000000000000000000000000000000",
      "workerpoolrestrict": "0x0000000000000000000000000000000000000000",
      "requesterrestrict": "0x0000000000000000000000000000000000000000"
    }

Creating an App Order [â€‹](#creating-an-app-order)
-------------------------------------------------

### Step 1: Install the iExec SDK [â€‹](#step-1-install-the-iexec-sdk)

Since iApp Generator doesn't handle orders yet, you need to use the iExec SDK CLI. For detailed installation instructions, see the [iExec SDK documentation](/references/sdk).

npmyarnpnpmbun

sh

    npm install iexec

sh

    yarn add iexec

sh

    pnpm add iexec

sh

    bun add iexec

Verify the installation:

bash

    iexec --version
    iexec --help

### Step 2: Configure your iExec Project [â€‹](#step-2-configure-your-iexec-project)

In your iApp Generator project folder, initialize the iExec configuration:

bash

    # In your iApp Generator project folder
    iexec init --skip-wallet

This creates the necessary configuration files:

*   `iexec.json` - Project configuration
*   `chain.json` - Blockchain configuration

### Step 3: Configure your Wallet [â€‹](#step-3-configure-your-wallet)

If you don't have an iExec wallet yet:

bash

    iexec wallet create

Or import an existing wallet:

bash

    iexec wallet import <private-key>

iApp Generator Users

If you used iApp Generator, you already have an `iapp.config.json` file with a generated private key. You can use this existing private key to initialize your wallet:

bash

    # Extract the private key from your `iapp.config.json`
    iexec wallet import <your-private-key>

Check your wallet:

bash

    iexec wallet show

### Step 4: Create the App Order [â€‹](#step-4-create-the-app-order)

Initialize the app order:

bash

    iexec order init --app

This adds an `apporder` section to your `iexec.json`. Edit the parameters according to your needs:

json

    {
      "apporder": {
        "app": "0xYourAppAddress",
        "appprice": "1000000000",
        "volume": "100",
        "tag": "0x0000000000000000000000000000000000000000000000000000000000000003",
        "datasetrestrict": "0x0000000000000000000000000000000000000000",
        "workerpoolrestrict": "0x0000000000000000000000000000000000000000",
        "requesterrestrict": "0x0000000000000000000000000000000000000000"
      }
    }

### Step 5: Sign and Publish the Order [â€‹](#step-5-sign-and-publish-the-order)

Sign your app order with your wallet:

bash

    iexec order sign --app

Publish the order on the marketplace:

bash

    iexec order publish --app

Your iApp is now accessible according to the conditions you defined!

Managing orders [â€‹](#managing-orders)
-------------------------------------

### View published orders [â€‹](#view-published-orders)

Check active orders for your app:

bash

    iexec orderbook app <your-app-address>

### Modify an Order [â€‹](#modify-an-order)

To change conditions, create a new order with new parameters.

### Cancel an Order [â€‹](#cancel-an-order)

Remove an order from the marketplace:

bash

    iexec order unpublish --app <orderHash>

Completely invalidate an order:

bash

    iexec order cancel --app <orderHash>

### **Confidential App (TEE Required)** [â€‹](#confidential-app-tee-required)

json

    {
      "appprice": "2000000000",
      "volume": "500",
      "tag": "0x0000000000000000000000000000000000000000000000000000000000000003"
    }

App order parameters [â€‹](#app-order-parameters)
-----------------------------------------------

Here's the detailed description of each parameter:

### `app` required [â€‹](#app)

**Description:** Ethereum address of your deployed iApp

**Example:** `"0x123abc456def..."`

### `appprice` optional [â€‹](#appprice)

**Description:** Price to charge per execution (in nano RLC - nRLC)

**Common values:**

*   `"0"` - Free
*   `"1000000000"` - 1 RLC per execution
*   `"500000000"` - 0.5 RLC per execution

TIP

1 RLC = 1,000,000,000 nano RLC (10^9)

### `volume` optional [â€‹](#volume)

**Description:** Number of authorized executions (decrements with each use)

**Examples:**

*   `1` - Single use
*   `100` - Limited campaign
*   `10000` - Virtually unlimited usage

### `tag` optional [â€‹](#tag)

**Description:** Specifies the required execution environment

**Supported values:**

Value

Description

`0x0000000000000000000000000000000000000000000000000000000000000000`

Standard execution

`0x0000000000000000000000000000000000000000000000000000000000000003`

TEE required (Scone)

### Access restrictions [â€‹](#access-restrictions)

All restrictions use `0x0000000000000000000000000000000000000000` to indicate "no restriction".

#### `datasetrestrict` optional [â€‹](#datasetrestrict)

**Description:** Restrict usage to a specific dataset

**Typical usage:** `0x0000000000000000000000000000000000000000` (no restriction)

#### `workerpoolrestrict` optional [â€‹](#workerpoolrestrict)

**Description:** Restrict execution to a specific workerpool

**Example:** `prod-v8-bellecour.main.pools.iexec.eth` for the main workerpool

#### `requesterrestrict` optional [â€‹](#requesterrestrict)

**Description:** Restrict usage to a specific user

**Typical usage:** `0x0000000000000000000000000000000000000000` (open to all)

What's Next? [â€‹](#what-s-next)
------------------------------

**Your iApp is now accessible with custom conditions!**

Next steps:

*   **Monitor executions**: Track usage with `iexec task show`
*   **Adjust pricing**: Create new orders based on demand
*   **Manage revenue**: Check your earnings with `iexec account show`

### Technical deep dive [â€‹](#technical-deep-dive)

*   **[iExec SDK Documentation](/references/sdk)** - Complete CLI reference

Inputs [â€‹](#inputs)
===================

**Your iApp runs inside a secure TEE environment with access to different types of inputs.** Understanding what data you can access, how to access it, and when to use each type is crucial for building effective privacy-preserving applications.

This guide covers all input types available to your iApp and how to access them within the TEE environment.

Two perspectives on inputs [â€‹](#two-perspectives-on-inputs)
-----------------------------------------------------------

**Inputs work differently depending on your role:**

*   ðŸ”§ **As a developer** (using iApp Generator): You write code to access inputs from the TEE environment
*   ðŸ‘¤ **As a user** (using DataProtector): You provide inputs when executing the iApp via `processProtectedData()`

TIP

You can also execute iApp outside of DataProtector using other methods. See the [Run iApp without ProtectedData](/guides/use-iapp/run-iapp-without-ProtectedData) guide for more information.

This guide shows both perspectives for each input type.

Input types overview [â€‹](#input-types-overview)
-----------------------------------------------

Inside the TEE, your iApp can work with five distinct categories of inputs:

Input Type

Visibility

Security Level

Purpose

How iApp Accesses It

**Protected Data**

Public

Encrypted

Data to be processed

Clear files in TEE

**Args**

Public

Clear

Configuration parameters

Command line arguments

**Input Files**

Public

Clear

Large datasets, models

Clear files in TEE

**Requester Secrets**

Private

Encrypted

User's sensitive data

Environment variables

**App Secrets**

Private

Encrypted

Developer's sensitive data

Environment variables

1\. Protected Data [â€‹](#_1-protected-data)
------------------------------------------

**What it is:** Encrypted data that's only decrypted inside your TEE environment.

**When to use:** Processing sensitive information like personal data, financial records, health data.

### How to Access Protected Data [â€‹](#how-to-access-protected-data)

Protected data is available in the `IEXEC_IN` directory as decrypted files:

PythonJavaScript

python

    import os
    import json
    
    # Get the input directory and dataset filename
    iexec_in = os.environ['IEXEC_IN']
    data_filename = os.environ['IEXEC_DATASET_FILENAME']
    
    # Protected data is decrypted and available as files
    try:
        # For single protected data
        with open(f"{iexec_in}/{data_filename}", 'r') as f:
            data = json.load(f)
    
        # Access the sensitive data
        user_email = data.get('email')
        user_preferences = data.get('preferences')
    
        print(f"Processing data for user: {user_email}")
    
    except FileNotFoundError:
        print("No protected data provided")

javascript

    const fs = require('fs');
    const path = require('path');
    
    // Get the input directory and dataset filename
    const iexecIn = process.env.IEXEC_IN;
    const dataFilename = process.env.IEXEC_DATASET_FILENAME;
    
    try {
      // Protected data is decrypted and available as files
      const dataPath = path.join(iexecIn, dataFilename);
      const data = JSON.parse(fs.readFileSync(dataPath, 'utf8'));
    
      // Access the sensitive data
      const userEmail = data.email;
      const userPreferences = data.preferences;
    
      console.log(`Processing data for user: ${userEmail}`);
    } catch (error) {
      console.log('No protected data provided');
    }

### How users provide protected data [â€‹](#how-users-provide-protected-data)

Users specify the protected data address when executing your iApp:

ts

    // User provides the protected data they want to use for processing
    const response = await dataProtectorCore.processProtectedData({
      protectedData: '0x123abc...', // Address of the protected data
      app: '0x456def...', // Your iApp address
    });

WARNING

Protected data is decrypted and loaded into TEE enclave memory. Very large datasets (>1-2GB) may cause out-of-memory errors. Consider data preprocessing or chunking for large datasets.

2\. Arguments (Args) [â€‹](#_2-arguments-args)
--------------------------------------------

**What they are:** Public parameters passed to your iApp during execution.

**When to use:** Configuration settings, model parameters, processing options - anything that doesn't need to be secret.

DANGER

Args are **completely public** and visible on the blockchain explorer. Never pass sensitive information through args.

### How to Access Args [â€‹](#how-to-access-args)

In your iApp project, args are passed as command-line arguments:

PythonJavaScript

python

    import sys
    
    # Access args from command line
    args = sys.argv[1:]  # Skip first arg (script name)
    
    # Example: iapp run myapp --args "model=bert threshold=0.8"
    if len(args) >= 2:
        model_name = args[0]      # "model=bert"
        threshold = args[1]       # "threshold=0.8"

javascript

    // Access args from command line
    const args = process.argv.slice(2); // Skip node and script name
    
    // Example: iapp run myapp --args "model=bert threshold=0.8"
    if (args.length >= 2) {
      const modelName = args[0]; // "model=bert"
      const threshold = args[1]; // "threshold=0.8"
    }

### How users provide args [â€‹](#how-users-provide-args)

Users pass args through the DataProtector `processProtectedData()` call:

ts

    // User provides args when executing your iApp
    const response = await dataProtectorCore.processProtectedData({
      protectedData: '0x123abc...',
      app: '0x456def...',
      args: 'model=sentiment-bert temperature=0.7 format=json', // Public arguments
    });

### Example use cases [â€‹](#example-use-cases)

*   Model configuration: `"model=sentiment-bert temperature=0.7"`
*   Processing options: `"format=json output_size=small"`
*   Analysis parameters: `"start_date=2024-01-01 end_date=2024-12-31"`

3\. Input Files [â€‹](#_3-input-files)
------------------------------------

**What they are:** Files downloaded from public URLs during iApp execution.

**When to use:** Large datasets, ML models, reference files that don't contain sensitive information.

### How to Access Input Files [â€‹](#how-to-access-input-files)

Files are downloaded to the `IEXEC_INPUT_FILES_FOLDER` directory:

PythonJavaScript

python

    import os
    
    # Get the input files directory
    input_dir = os.environ.get('IEXEC_INPUT_FILES_FOLDER', './input')
    
    # List all downloaded files
    for filename in os.listdir(input_dir):
        file_path = os.path.join(input_dir, filename)
    
        # Process your file
        with open(file_path, 'r') as f:
            content = f.read()
            print(f"Loaded file: {filename}")

javascript

    const fs = require('fs');
    const path = require('path');
    
    // Get the input files directory
    const inputDir = process.env.IEXEC_INPUT_FILES_FOLDER || './input';
    
    // List all downloaded files
    fs.readdirSync(inputDir).forEach((filename) => {
      const filePath = path.join(inputDir, filename);
    
      // Process your file
      const content = fs.readFileSync(filePath, 'utf8');
      console.log(`Loaded file: ${filename}`);
    });

### How Users Provide Input Files [â€‹](#how-users-provide-input-files)

Users specify input files when executing your iApp:

ts

    // User provides input files via DataProtector
    const response = await dataProtectorCore.processProtectedData({
      protectedData: '0x123abc...',
      app: '0x456def...',
      inputFiles: [
        'https://example.com/sentiment-model.pkl',
        'https://myapp.com/config.json',
      ],
    });

### Example use cases [â€‹](#example-use-cases-1)

*   ML model files: `"https://example.com/sentiment-model.pkl"`
*   Reference datasets: `"https://data.gov/reference-corpus.csv"`
*   Configuration files: `"https://myapp.com/config.json"`

WARNING

*   **File size**: Limited by TEE enclave memory (typically 1-2GB max)
*   **Memory constraint**: Files are loaded into enclave memory - large files may cause out-of-memory errors
*   **Format**: Any format (binary, text, compressed)
*   **URLs**: Must be direct download links (not web pages)
*   **Security**: Files are public - don't use for sensitive data

4\. Requester Secrets [â€‹](#_4-requester-secrets)
------------------------------------------------

**What they are:** Confidential data provided by the user running your iApp.

**When to use:** API keys, database credentials, authentication tokens that the user needs to provide.

### How to Access Requester Secrets [â€‹](#how-to-access-requester-secrets)

Secrets are available as environment variables with the pattern `IEXEC_REQUESTER_SECRET_<INDEX>`:

PythonJavaScript

python

    import os
    
    # Access requester secrets by index
    api_key = os.environ.get('IEXEC_REQUESTER_SECRET_1')
    db_password = os.environ.get('IEXEC_REQUESTER_SECRET_2')
    
    if api_key:
        # Use the API key for external service calls
        headers = {'Authorization': f'Bearer {api_key}'}
        # Make API calls...
    else:
        print("No API key provided")

javascript

    // Access requester secrets by index
    const apiKey = process.env.IEXEC_REQUESTER_SECRET_1;
    const dbPassword = process.env.IEXEC_REQUESTER_SECRET_2;
    
    if (apiKey) {
      // Use the API key for external service calls
      const headers = { Authorization: `Bearer ${apiKey}` };
      // Make API calls...
    } else {
      console.log('No API key provided');
    }

### How Users Provide Requester Secrets [â€‹](#how-users-provide-requester-secrets)

Users provide all Requester Secrets when executing your iApp via DataProtector:

ts

    // Example: User executes your iApp with all input types
    const processProtectedDataResponse =
      await dataProtectorCore.processProtectedData({
        protectedData: '0x123abc...', // Protected data address
        app: '0x456def...', // Your iApp address
        args: 'model=bert threshold=0.8', // Public arguments
        secrets: {
          // Requester secrets
          1: 'sk-1234567890abcdef', // API key
          2: 'mydbpassword123', // DB password
        },
      });

5\. App Secrets [â€‹](#_5-app-secrets)
------------------------------------

**What they are:** App Secrets are confidential data owned by the iApp developer that are provisioned during app deployment and made available to your iApp during execution. They are stored securely in the Secret Management Service (SMS) and only accessible within the Trusted Execution Environment (TEE).

**When to use:** Use App Secrets for API keys, private keys, tokens, database credentials, or any sensitive data that belongs to the app developer and needs to be available to the iApp during execution. Unlike Requester Secrets (which are provided by users), App Secrets are configured once by the developer and remain constant across all executions.

INFO

App Secrets are different from Requester Secrets:

*   **App Secrets**: Owned by the app developer, configured once during deployment
*   **Requester Secrets**: Owned by the user executing the iApp, provided per execution

### How to Use App Secrets in Your iApp [â€‹](#how-to-use-app-secrets-in-your-iapp)

App Secrets are configured in your `iapp.config.json` during development and automatically deployed with your iApp. For deployment details, see the [Build Your iApp guide](/references/iapp-generator/building-your-iexec-app).

#### Configuration in iapp.config.json [â€‹](#configuration-in-iapp-config-json)

Add your App Secret to the project configuration:

json

    {
      "defaultChain": "arbitrum",
      "projectName": "my-iapp",
      "template": "JavaScript",
      "appSecret": "{\"API_KEY\":\"sk-1234567890abcdef\",\"DATABASE_URL\":\"postgresql://user:pass@host:5432/db\"}"
    }

WARNING

*   **Size limit**: App secrets are limited to 4096 kB maximum
*   **Immutable**: Once set, app secrets cannot be changed without redeploying the iApp
*   **Security**: App secrets are encrypted and only accessible within the TEE environment
*   **Ownership**: App secrets belong to the iApp developer, not the user executing the iApp

### How to Access App Secrets [â€‹](#how-to-access-app-secrets)

App secrets are exposed as environment variables following the `IEXEC_APP_DEVELOPER_SECRET` naming pattern.

PythonJavaScript

python

    import os
    import json
    
    # Get your app secret
    app_secret = os.environ.get('IEXEC_APP_DEVELOPER_SECRET')
    
    if app_secret:
        # Parse JSON (multiple secrets)
        secrets = json.loads(app_secret)
        api_key = secrets.get('API_KEY')
        database_url = secrets.get('DATABASE_URL')

javascript

    // Get your app secret
    const appSecret = process.env.IEXEC_APP_DEVELOPER_SECRET;
    
    if (appSecret) {
      // Parse JSON (multiple secrets)
      const secrets = JSON.parse(appSecret);
      const apiKey = secrets.API_KEY;
      const databaseUrl = secrets.DATABASE_URL;
    }

Testing Inputs Locally [â€‹](#testing-inputs-locally)
---------------------------------------------------

Use iApp Generator to test different input types:

bash

    # Test with different input types
    iapp test --args "model=bert threshold=0.8"           # Test with arguments
    iapp test --inputFiles "https://example.com/data.json" # Test with input files
    iapp test --secrets "key1=value1,key2=value2"        # Test with secrets
    
    # Mock protected data for testing
    iapp mock protectedData  # Generate sample protected data
    
    # Test your iApp locally with mocked protected data
    iapp test --protectedData "mock_name"

Common Patterns [â€‹](#common-patterns)
-------------------------------------

### **Data Analysis iApp** [â€‹](#data-analysis-iapp)

**User execution (DataProtector):**

ts

    // User runs your data analysis iApp
    const response = await dataProtectorCore.processProtectedData({
      protectedData: '0x123abc...', // Their business data
      app: '0x456def...', // Your analysis iApp
      args: 'analysis_type=sentiment period=monthly',
      secrets: { 1: 'api-key-for-external-service' },
    });

**Your iApp code (Python):**

python

    # Access inputs in your iApp
    args = sys.argv[1:]           # Processing parameters
    api_key = os.environ.get('IEXEC_REQUESTER_SECRET_1')  # User's API access
    protected_data = load_protected_data()  # The sensitive data to process
    
    # Process and output results
    results = analyze_data(protected_data, args, api_key)
    save_results(results)

### **AI Model iApp** [â€‹](#ai-model-iapp)

**User execution (DataProtector):**

ts

    // User runs your AI model with their data
    const response = await dataProtectorCore.processProtectedData({
      protectedData: '0x123abc...', // Their personal data
      app: '0x456def...', // Your AI model iApp
      inputFiles: ['https://example.com/model-weights.pkl'],
      args: 'model_type=classification confidence_threshold=0.8',
    });

**Your iApp code (Python):**

python

    # Load model from input files
    model = load_model_from_inputs()
    
    # Get user data to process
    user_data = load_protected_data()
    
    # Run inference
    predictions = model.predict(user_data)
    
    # Return encrypted results
    save_encrypted_results(predictions)

### **Report Generator iApp** [â€‹](#report-generator-iapp)

**User execution (DataProtector):**

ts

    // User generates a report from their business data
    const response = await dataProtectorCore.processProtectedData({
      protectedData: '0x123abc...', // Their business data
      app: '0x456def...', // Your report generator iApp
      args: 'report_type=quarterly format=pdf include_charts=true',
      inputFiles: ['https://example.com/company-template.xlsx'],
    });

**Your iApp code (Python):**

python

    # Get configuration from args
    report_type = get_arg('type', default='summary')
    
    # Access the business data
    business_data = load_protected_data()
    
    # Generate report
    report = generate_report(business_data, report_type)
    save_report(report)

What's Next? [â€‹](#what-s-next)
------------------------------

**You now understand all input types available to your iApp!**

Continue building with these guides:

*   **[Outputs](/guides/build-iapp/outputs)** - Learn how to generate and structure your iApp outputs
*   **[App Access Control and Pricing](/guides/build-iapp/manage-access)** - Control who can use your iApp
*   **[Debugging Your iApp](/guides/build-iapp/debugging)** - Troubleshoot execution issues

Outputs [â€‹](#outputs)
=====================

**Your iApp must generate outputs that users can retrieve and decrypt.** Understanding how to structure your outputs, create the required metadata, and follow best practices is essential for building effective privacy-preserving applications.

This guide covers how to generate outputs from your iApp and ensure they can be properly retrieved by users.

Creating Outputs [â€‹](#creating-outputs)
---------------------------------------

Your iApp must generate outputs in the `IEXEC_OUT` directory. **Every iApp must create a `computed.json` file** with metadata about the computation.

### Basic Output Structure [â€‹](#basic-output-structure)

PythonJavaScript

python

    import os
    import json
    
    # Get output directory
    iexec_out = os.environ['IEXEC_OUT']
    
    # Create your result file
    result_data = {
        "analysis": "positive sentiment",
        "confidence": 0.92,
        "processed_at": "2024-01-15T10:30:00Z"
    }
    
    # Save main result
    with open(f"{iexec_out}/result.json", 'w') as f:
        json.dump(result_data, f)
    
    # REQUIRED: Create `computed.json` metadata
    computed_metadata = {
        "deterministic-output-path": f"{iexec_out}/result.json",
        "execution-timestamp": "2024-01-15T10:30:00Z",
        "app-version": "1.0.0"
    }
    
    with open(f"{iexec_out}/computed.json", 'w') as f:
        json.dump(computed_metadata, f)

javascript

    const fs = require('fs');
    const path = require('path');
    
    // Get output directory
    const iexecOut = process.env.IEXEC_OUT;
    
    // Create your result file
    const resultData = {
      analysis: 'positive sentiment',
      confidence: 0.92,
      processed_at: '2024-01-15T10:30:00Z',
    };
    
    // Save main result
    fs.writeFileSync(
      path.join(iexecOut, 'result.json'),
      JSON.stringify(resultData, null, 2)
    );
    
    // REQUIRED: Create computed.json metadata
    const computedMetadata = {
      'deterministic-output-path': path.join(iexecOut, 'result.json'),
      'execution-timestamp': '2024-01-15T10:30:00Z',
      'app-version': '1.0.0',
    };
    
    fs.writeFileSync(
      path.join(iexecOut, 'computed.json'),
      JSON.stringify(computedMetadata, null, 2)
    );

### Output Best Practices [â€‹](#output-best-practices)

1.  **Always create `computed.json`** - This is mandatory
2.  **Use descriptive filenames** - `analysis_result.json`, not `output.txt`
3.  **Include metadata** - Timestamps, versions, parameters used
4.  **Structure your data** - Use JSON for structured results
5.  **Keep files reasonable** - Large outputs increase retrieval time and may hit memory limits
6.  **Memory awareness** - TEE enclave memory is limited, avoid generating multi-GB outputs

### Example: Multi-file Output [â€‹](#example-multi-file-output)

python

    import os
    import json
    
    iexec_out = os.environ['IEXEC_OUT']
    
    # Create multiple output files
    summary = {"total_processed": 1000, "success_rate": 0.95}
    with open(f"{iexec_out}/summary.json", 'w') as f:
        json.dump(summary, f)
    
    # Create a detailed report
    with open(f"{iexec_out}/detailed_report.txt", 'w') as f:
        f.write("Detailed analysis results...\n")
    
    # Create visualization data
    chart_data = {"labels": ["A", "B", "C"], "values": [10, 20, 30]}
    with open(f"{iexec_out}/chart_data.json", 'w') as f:
        json.dump(chart_data, f)
    
    # Required metadata file
    computed = {
        "deterministic-output-path": f"{iexec_out}/summary.json",
        "additional-files": [
            f"{iexec_out}/detailed_report.txt",
            f"{iexec_out}/chart_data.json"
        ]
    }
    with open(f"{iexec_out}/computed.json", 'w') as f:
        json.dump(computed, f)

What's Next? [â€‹](#what-s-next)
------------------------------

**You now understand how to generate proper outputs from your iApp!**

Continue building with these guides:

*   **[Inputs](/guides/build-iapp/inputs)** - Learn about the different input types available to your iApp
*   **[App Access Control and Pricing](/guides/build-iapp/manage-access)** - Control who can use your iApp
*   **[Debugging Your iApp](/guides/build-iapp/debugging)** - Troubleshoot execution issues

Debugging [â€‹](#debugging)
=========================

**When your iApp doesn't work as expected, debugging in the TEE environment requires specific techniques.** This guide helps you identify issues and optimize your iApp's performance.

Task Execution Lifecycle [â€‹](#task-execution-lifecycle)
-------------------------------------------------------

Understanding how your task progresses through the iExec network:

### Key Stages [â€‹](#key-stages)

1.  **Deal Creation** - Orders matched, funds locked
2.  **Task Initialization** - Workers selected for execution
3.  **iApp Execution** - Your code runs inside TEE
4.  **Result Processing** - Results encrypted and uploaded
5.  **Task Completion** - Results available for download

**Most failures happen during stages 2-4**

Monitoring your Tasks [â€‹](#monitoring-your-tasks)
-------------------------------------------------

### iExec Explorer [â€‹](#iexec-explorer)

Track your tasks at [iExec Explorer](https://explorer.iex.ec):

*   Search by `taskId` or deal ID
*   Check status: `PENDING` â†’ `ACTIVE` â†’ `COMPLETED/FAILED`
*   View error messages if execution fails

### Status in Code [â€‹](#status-in-code)

ts

    const response = await dataProtectorCore.processProtectedData({
      protectedData: '0x123abc...',
      app: '0x456def...',
      onStatusUpdate: ({ title, isDone }) => {
        console.log(`Status: ${title} - Done: ${isDone}`);
      },
    });

Debug Commands [â€‹](#debug-commands)
-----------------------------------

### Local Testing [â€‹](#local-testing)

bash

    # Test your iApp locally
    iapp test --args "model=bert threshold=0.8"
    iapp test --secrets "key1=value1,key2=value2"
    
    # Mock protected data for testing
    iapp mock protectedData
    iapp test --protectedData "mock_name"

### Remote Debugging [â€‹](#remote-debugging)

bash

    # Deploy and run
    iapp deploy
    iapp run <iapp-address>
    
    # Debug failed executions
    iapp debug <taskId>

### Task Information [â€‹](#task-information)

bash

    # View task details
    iexec task show <taskId>
    
    # Download results (if completed)
    iexec task show <taskId> --download

Common Issues [â€‹](#common-issues)
---------------------------------

### **Task Timeout** [â€‹](#task-timeout)

*   **Cause**: Code takes too long to execute
*   **Solution**: Optimize algorithms, reduce input sizes, use appropriate task category

### **Memory Issues** [â€‹](#memory-issues)

*   **Cause**: Loading large files, memory leaks, TEE constraints
*   **Solution**: Process data in chunks, use streaming, optimize memory usage

### **Input/Output Problems** [â€‹](#input-output-problems)

*   **Cause**: Wrong file paths, missing `computed.json`
*   **Solution**: Always create `computed.json`, verify environment variables

python

    # Always create computed.json
    import json, os
    computed = {"deterministic-output-path": f"{os.environ['IEXEC_OUT']}/result.json"}
    with open(f"{os.environ['IEXEC_OUT']}/computed.json", 'w') as f:
        json.dump(computed, f)

### **Dataset Type Unmatching** [â€‹](#dataset-type-unmatching)

*   **Cause**: The dataset type specified in the frontend (protectData) does not match with the dataset type specified in the iApp
*   **Solution**: Check both dataset types

Best Practices [â€‹](#best-practices)
-----------------------------------

### **Input Validation** [â€‹](#input-validation)

python

    import os, sys
    
    # Check required environment variables
    if not os.environ.get('IEXEC_IN') or not os.environ.get('IEXEC_OUT'):
        print("ERROR: Missing IEXEC_IN or IEXEC_OUT")
        sys.exit(1)
    
    # Validate arguments
    if len(sys.argv) < 2:
        print("ERROR: Missing required arguments")
        sys.exit(1)

### **Clear Error Messages** [â€‹](#clear-error-messages)

python

    try:
        # Your processing logic
        result = process_data(data)
    except Exception as e:
        print(f"ERROR: Processing failed: {str(e)}")
        sys.exit(1)

### **Safe File Operations** [â€‹](#safe-file-operations)

python

    import os, json
    
    # Always ensure output directory exists
    iexec_out = os.environ['IEXEC_OUT']
    os.makedirs(iexec_out, exist_ok=True)
    
    # Write results safely
    try:
        with open(f"{iexec_out}/result.json", 'w') as f:
            json.dump(result_data, f)
    except Exception as e:
        print(f"ERROR: Failed to write results: {e}")
        sys.exit(1)

What's Next? [â€‹](#what-s-next)
------------------------------

Continue improving your iApp:

*   **[Inputs](/guides/build-iapp/inputs)** - Handle data inputs
*   **[Outputs](/guides/build-iapp/outputs)** - Handle data outputs in TEE

Quick Start [â€‹](#quick-start)
=============================

> This tutorial shows how to create decentralized app over the iExec infrastructure.

iExec enables decentralized docker app deployment and monetization on the blockchain.

This guide uses the iExec SDK command-line interface to deploy an iExec app on a test blockchain.

Install the iExec SDK [â€‹](#install-the-iexec-sdk)
-------------------------------------------------

For complete installation instructions and requirements, see the [iExec SDK documentation](/references/sdk).

Requirements: [![npm version](https://img.shields.io/badge/nodejs-%3E=18.0.0-brightgreen.svg)](https://nodejs.org/en/)

bash

    npm -g install iexec # install the CLI
    iexec --version
    iexec --help

Create your identity on the blockchain [â€‹](#create-your-identity-on-the-blockchain)
-----------------------------------------------------------------------------------

On the blockchain, your identity is defined by your **wallet,** consisting of cryptographically encrypted **private key** and **public address.** What you own on the blockchain is associated with your address. The applications you deploy on iExec are associated with your wallet.

Let's set up your wallet.

Create a new Wallet file

text

    iexec wallet create

You will be asked to choose a password to protect your wallet, don't forget it since there is no way to recover it. The SDK creates a wallet file that contains a randomly generated private key encrypted by the chosen password and the derived public address. Make sure to back up the wallet file in a safe place and write down your address.

Your wallet is stored in the ethereum keystore, the location depends on

your OS:

*   On Linux: ~/.ethereum/keystore
*   On Mac : ~/Library/Ethereum/keystore
*   On Windows: ~/AppData/Roaming/Ethereum/keystore

Wallet file name follow the pattern `UTC--<CREATION_DATE>--<ADDRESS>`

INFO

iExec SDK uses standard Ethereum wallet, you can reuse or import existing Ethereum wallet. See iExec SDK documentation [wallet command](https://github.com/iExecBlockchainComputing/iexec-sdk/blob/v8.1.5/CLI.md#iexec-wallet).

What's next? [â€‹](#what-s-next)
------------------------------

You are now familiar with the following key iExec concepts for developers:

*   Your wallet is your on-chain ID and blockchain account
*   You can deploy decentralized applications on iExec
*   Anyone can run tasks against payment in RLC on iExec
*   Payments are processed by the decentralized platform between users' iExec Accounts
*   Resource governance is managed by orders

Continue with these guides:

*   [Learn how to build your first confidential application running on iExec](/guides/build-iapp/advanced/build-your-first-sgx-iapp)

Build your first app with Scone framework [â€‹](#build-your-first-app-with-scone-framework)
=========================================================================================

In this tutorial, you will learn how to build and run a Confidential Computing app with the Scone TEE framework.

Prerequisites:

*   [Docker](https://docs.docker.com/install/) 17.05 or higher on the daemon and client.
*   [iExec SDK](https://www.npmjs.com/package/iexec) 8.0.0 or higher.
*   Familiarity with the basic concepts of [IntelÂ® SGX](/protocol/tee/intel-sgx) and [SCONE](https://scontain.com) framework.

In order to follow this tutorial, you will need to register a [free SCONE Account](https://scontain.com) to access SCONE build tools and curated images from the [SCONE registry](https://gitlab.scontain.com/).

Once your account is activated, you need to [request access to the SCONE build tools for iExec](mailto:info@scontain.com?cc=scone-access@iex.ec&subject=iExec%20Build%20Tools&body=Hi%20SCONE%20Team%2C%0D%0A%0D%0AI%20would%20like%20to%20get%20access%20to%20the%20SCONE%20build%20tools%20for%20iExec:%0A%20-%20scone-production/iexec-sconify-image%0A%20-%20sconecuratedimages%20%28all%20curated%20images%20such%20as%20nodejs%2C%20python...%29%0A%0AMy%20DockerID%20is%20...%0A%0ABest%20regards%0A%0A...).

bash

    # when your account is ready, run `docker login` to connect the SCONE registry
    docker login registry.scontain.com

Prepare your app [â€‹](#prepare-your-app)
---------------------------------------

Before going further, your `<docker-hub-user>/hello-world:1.0.0` image built previously is required.

For this tutorial, create a new directory tree. Execute the following commands in `~/iexec-projects/`:

bash

    cd ~/iexec-projects
    mkdir tee-hello-world-app && cd tee-hello-world-app
    iexec init --skip-wallet
    mkdir src
    touch Dockerfile
    touch sconify.sh
    chmod +x sconify.sh

### Write the iApp logic [â€‹](#write-the-iapp-logic)

Develop your code logic like the content below.The following examples only feature Javascript and Python use cases for simplicity concerns but remember that you can run on iExec anything which is Dockerizable.

**Copy the following content** in `src/` .

src/app.jssrc/app.py

javascript

    const fsPromises = require('fs').promises;
    
    (async () => {
      try {
        const iexecOut = process.env.IEXEC_OUT;
        // Do whatever you want (let's write hello world here)
        const message = process.argv.length > 2 ? process.argv[2] : 'World';
    
        const text = `Hello, ${message}!`;
        console.log(text);
        // Append some results in /iexec_out/
        await fsPromises.writeFile(`${iexecOut}/result.txt`, text);
        // Declare everything is computed
        const computedJsonObj = {
          'deterministic-output-path': `${iexecOut}/result.txt`,
        };
        await fsPromises.writeFile(
          `${iexecOut}/computed.json`,
          JSON.stringify(computedJsonObj)
        );
      } catch (e) {
        console.log(e);
        process.exit(1);
      }
    })();

python

    import os
    import sys
    import json
    
    iexec_out = os.environ['IEXEC_OUT']
    
    # Do whatever you want (let's write hello world here)
    text = 'Hello, {}!'.format(sys.argv[1] if len(sys.argv) > 1 else "World")
    print(text)
    
    # Append some results in /iexec_out/
    with open(iexec_out + '/result.txt', 'w+') as fout:
        fout.write(text)
    
    # Declare everything is computed
    with open(iexec_out + '/computed.json', 'w+') as f:
        json.dump({ "deterministic-output-path" : iexec_out + '/result.txt' }, f)

WARNING

As a developer, make it a rule to never log sensitive information in your application. Execution logs are accessible by:

*   worker(s) involved in the task
*   the workerpool manager
*   the requester of the task

### Dockerize your iApp [â€‹](#dockerize-your-iapp)

**Copy the following content** in `Dockerfile` .

Dockerfile for JavaScriptDockerfile for Python

bash

    FROM node:22-alpine3.21
    ### install your dependencies if you have some
    RUN mkdir /app && cd /app
    COPY ./src /app
    ENTRYPOINT [ "node", "/app/app.js"]

bash

    FROM python:3.13.3-alpine3.21
    ### install python dependencies if you have some
    COPY ./src /app
    ENTRYPOINT ["python3", "/app/app.py"]

Build the docker image.

WARNING

iExec expects your Docker container to be built for the `linux/amd64` platform. However, if you develop on a **Mac** with Apple **M processor**, the platform is `linux/arm64`, which is different. To prepare your application, you will need to install `buildkit` and then prepare your docker image for both platforms.

bash

    brew install buildkit
    # ARM64 variant for local testing only
    docker buildx build --platform linux/arm64 --tag <docker-hub-user>/hello-world .
    # AMD64 variant to deploy on iExec
    docker buildx build --platform linux/amd64 --tag <docker-hub-user>/hello-world .

bash

    docker build --tag hello-world .

TIP

`docker build` produce an image id, using `--tag <name>` option is a convenient way to name the image to reuse it in the next steps.

**Congratulations you built your first docker image for iExec!**

Test your iApp locally [â€‹](#test-your-iapp-locally)
---------------------------------------------------

### Basic test [â€‹](#basic-test)

Create local volumes to simulate input and output directories.

bash

    mkdir -p ./tmp/iexec_in
    mkdir -p ./tmp/iexec_out

Run your application locally (container volumes bound with local volumes).

bash

    docker run --rm \
        -v ./tmp/iexec_in:/iexec_in \
        -v ./tmp/iexec_out:/iexec_out \
        -e IEXEC_IN=/iexec_in \
        -e IEXEC_OUT=/iexec_out \
        hello-world arg1 arg2 arg3

Docker run \[options\] image \[args\]

**docker run usage:**

`docker run [OPTIONS] IMAGE [COMMAND] [ARGS...]`

Use `[COMMAND]` and `[ARGS...]` to simulate the requester arguments

**useful options for iExec:**

`-v` : Bind mount a volume. Use it to bind input and output directories (`/iexec_in` and `/iexec_out`)

`-e`: Set environnement variable. Use it to simulate iExec Runtime variables

### Test with input files [â€‹](#test-with-input-files)

Starting with the basic test you can simulate input files.

For each input file:

*   Copy it in the local volume bound to `/iexec_in` .
*   Add `-e IEXEC_INPUT_FILE_NAME_x=NAME` to docker run options (`x` is the index of the file starting by 1 and `NAME` is the name of the file)

Add `-e IEXEC_INPUT_FILES_NUMBER=n` to docker run options (`n` is the total number of input files).

Example with two inputs files:

bash

    touch ./tmp/iexec_in/file1 && \
    touch ./tmp/iexec_in/file2 && \
    docker run \
        -v ./tmp/iexec_in:/iexec_in \
        -v ./tmp/iexec_out:/iexec_out \
        -e IEXEC_IN=/iexec_in \
        -e IEXEC_OUT=/iexec_out \
        -e IEXEC_INPUT_FILE_NAME_1=file1 \
        -e IEXEC_INPUT_FILE_NAME_2=file2 \
        -e IEXEC_INPUT_FILES_NUMBER=2 \
        hello-world \
        arg1 arg2 arg3

Build the TEE docker image [â€‹](#build-the-tee-docker-image)
-----------------------------------------------------------

Before wrapping your iExec confidential app with Scone, you need to generate a custom signing key. The sconification process uses this key.

Generate your enclave signing key with:

bash

    openssl genrsa -3 -out enclave-key.pem 3072

This will create an `enclave-key.pem` file in your current directory. You will use this file in the sconify Docker command to sign your TEE image.

Use the following script to wrap the sconification process, copy the `sconify.sh` script in the current directory:

JavascriptPython

bash

    #!/bin/bash
    
    # Declare image related variables
    IMG_FROM=<docker-hub-user>/hello-world
    IMG_TO=<docker-hub-user>/tee-scone-hello-world:1.0.0
    
    # Run the sconifier to build the TEE image based on the non-TEE image
    docker run -it --rm \
                -v $PWD/enclave-key.pem:/sig/enclave-key.pem \
                -v /var/run/docker.sock:/var/run/docker.sock \
                registry.scontain.com/scone-production/iexec-sconify-image:5.9.1-v16\
                sconify_iexec \
                --scone-signer=/sig/enclave-key.pem \
                --from=${IMG_FROM} \
                --to=${IMG_TO} \
                --binary-fs \
                --fs-dir=/app \
                --host-path=/etc/hosts \
                --host-path=/etc/resolv.conf \
                --binary=/usr/local/bin/node \
                --heap=1G \
                --dlopen=1 \
                --verbose \
                && echo -e "\n------------------\n" \
                && echo "successfully built TEE docker image => ${IMG_TO}" \
                && echo "application mrenclave.fingerprint is $(docker run --rm -e SCONE_HASH=1 ${IMG_TO})"

bash

    #!/bin/bash
    
    # Declare image related variables
    IMG_FROM=<docker-hub-user>/hello-world
    IMG_TO=<docker-hub-user>/tee-scone-hello-world:1.0.0
    
    # Run the sconifier to build the TEE image based on the non-TEE image
    docker run -it --rm \
                -v $PWD/enclave-key.pem:/sig/enclave-key.pem \
                -v /var/run/docker.sock:/var/run/docker.sock \
                registry.scontain.com/scone-production/iexec-sconify-image:5.9.1-v16\
                sconify_iexec \
                --from=${IMG_FROM} \
                --to=${IMG_TO} \
                --binary-fs \
                --fs-dir=/app \
                --host-path=/etc/hosts \
                --host-path=/etc/resolv.conf \
                --binary=/usr/local/bin/python3 \
                --heap=1G \
                --dlopen=1 \
                --verbose \
                && echo -e "\n------------------\n" \
                && echo "successfully built TEE docker image => ${IMG_TO}" \
                && echo "application mrenclave.fingerprint is $(docker run --rm -e SCONE_HASH=1 ${IMG_TO})"

Run the `sconify.sh` script to build the Scone TEE app:

bash

    ./sconify.sh

Push your image on DockerHub:

bash

    docker login
    docker push <docker-hub-user>/tee-scone-hello-world:1.0.0

Congratulations, you just built your Scone TEE app.

Test your iApp on iExec [â€‹](#test-your-iapp-on-iexec)
-----------------------------------------------------

At this stage, your app is ready to be tested on iExec. The process is similar to testing any type of app on the platform, with these minor exceptions:

### Deploy the TEE iApp on iExec [â€‹](#deploy-the-tee-iapp-on-iexec)

TEE apps require some additional information to be filled in during deployment.

bash

    # prepare the TEE app template
    iexec app init --tee

Edit `iexec.json` and fill in the standard keys and the `mrenclave` object:

json

    {
      ...
      "app": {
        "owner": "<your-wallet-address>", // starts with 0x
        "name": "tee-scone-hello-world", // app name
        "type": "DOCKER",
        "multiaddr": "docker.io/<docker-hub-user>/tee-scone-hello-world:1.0.0", // app image
        "checksum": "<checksum>", // starts with 0x, update it with your own image digest
        "mrenclave": {
          "framework": "SCONE", // TEE framework (keep default value)
          "version": "v5.9", // Scone version (keep default value)
          "entrypoint": "node --disable-wasm-trap-handler /app/app.js" OR "python3 /app/app.py", // update it with your own image entrypoint
          "heapSize": 1073741824, // heap size in bytes, update it with --heap option value used in sconify.sh script during TEE image build
          "fingerprint": "<mrenclave>" // fingerprint of the enclave code (mrenclave), without 0x prefix, see how to retrieve it below
        }
      },
      ...
    }

INFO

Run your TEE image with `SCONE_HASH=1` to get the enclave fingerprint (mrenclave):

bash

    docker run --rm -e SCONE_HASH=1 <docker-hub-user>/tee-scone-hello-world:1.0.0

Deploy the iApp with the standard command:

bash

    iexec app deploy --chain bellecour

You can check your deployed apps with their index, let's check your last deployed app:

bash

    iexec app show --chain bellecour

Run the iApp [â€‹](#run-the-iapp)
-------------------------------

iExec allows you to run applications on a decentralized infrastructure with payment in **RLC** tokens.

INFO

To run an application you must have enough RLC staked on your iExec account to pay for the computing resources.

Your iExec account is managed by smart contracts (and not owned by iExec).

When you request an execution the price for the task is locked from your account's stake then transferred to accounts of the workers contributing to the task (read more about [Proof of Contribution](/protocol/proof-of-contribution) protocol).

At any time you can:

*   view your balance

bash

    iexec account show --chain bellecour

*   deposit RLC from your wallet to your iExec Account

bash

    iexec account deposit --chain bellecour <amount>

*   withdraw RLC from your iExec account to your wallet (only stake can be withdrawn)

bash

    iexec account withdraw --chain bellecour <amount>

One last thing, in order to run a **TEE** iApp you will also need to select a workerpool, use the iexec workerpool `prod-v8-bellecour.main.pools.iexec.eth`.

You are now ready to run the iApp

bash

    iexec app run --chain bellecour --tag tee,scone --workerpool prod-v8-bellecour.main.pools.iexec.eth --watch

The execution of tasks on the iExec network is asynchronous by design.

#mermaid-283{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#ccc;}@keyframes edge-animation-frame{from{stroke-dashoffset:0;}}@keyframes dash{to{stroke-dashoffset:0;}}#mermaid-283 .edge-animation-slow{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 50s linear infinite;stroke-linecap:round;}#mermaid-283 .edge-animation-fast{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 20s linear infinite;stroke-linecap:round;}#mermaid-283 .error-icon{fill:#a44141;}#mermaid-283 .error-text{fill:#ddd;stroke:#ddd;}#mermaid-283 .edge-thickness-normal{stroke-width:1px;}#mermaid-283 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-283 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-283 .edge-thickness-invisible{stroke-width:0;fill:none;}#mermaid-283 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-283 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-283 .marker{fill:lightgrey;stroke:lightgrey;}#mermaid-283 .marker.cross{stroke:lightgrey;}#mermaid-283 svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-283 p{margin:0;}#mermaid-283 .label{font-family:"trebuchet ms",verdana,arial,sans-serif;color:#ccc;}#mermaid-283 .cluster-label text{fill:#F9FFFE;}#mermaid-283 .cluster-label span{color:#F9FFFE;}#mermaid-283 .cluster-label span p{background-color:transparent;}#mermaid-283 .label text,#mermaid-283 span{fill:#ccc;color:#ccc;}#mermaid-283 .node rect,#mermaid-283 .node circle,#mermaid-283 .node ellipse,#mermaid-283 .node polygon,#mermaid-283 .node path{fill:#1f2020;stroke:#ccc;stroke-width:1px;}#mermaid-283 .rough-node .label text,#mermaid-283 .node .label text,#mermaid-283 .image-shape .label,#mermaid-283 .icon-shape .label{text-anchor:middle;}#mermaid-283 .node .katex path{fill:#000;stroke:#000;stroke-width:1px;}#mermaid-283 .rough-node .label,#mermaid-283 .node .label,#mermaid-283 .image-shape .label,#mermaid-283 .icon-shape .label{text-align:center;}#mermaid-283 .node.clickable{cursor:pointer;}#mermaid-283 .root .anchor path{fill:lightgrey!important;stroke-width:0;stroke:lightgrey;}#mermaid-283 .arrowheadPath{fill:lightgrey;}#mermaid-283 .edgePath .path{stroke:lightgrey;stroke-width:2.0px;}#mermaid-283 .flowchart-link{stroke:lightgrey;fill:none;}#mermaid-283 .edgeLabel{background-color:hsl(0, 0%, 34.4117647059%);text-align:center;}#mermaid-283 .edgeLabel p{background-color:hsl(0, 0%, 34.4117647059%);}#mermaid-283 .edgeLabel rect{opacity:0.5;background-color:hsl(0, 0%, 34.4117647059%);fill:hsl(0, 0%, 34.4117647059%);}#mermaid-283 .labelBkg{background-color:rgba(87.75, 87.75, 87.75, 0.5);}#mermaid-283 .cluster rect{fill:hsl(180, 1.5873015873%, 28.3529411765%);stroke:rgba(255, 255, 255, 0.25);stroke-width:1px;}#mermaid-283 .cluster text{fill:#F9FFFE;}#mermaid-283 .cluster span{color:#F9FFFE;}#mermaid-283 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:12px;background:hsl(20, 1.5873015873%, 12.3529411765%);border:1px solid rgba(255, 255, 255, 0.25);border-radius:2px;pointer-events:none;z-index:100;}#mermaid-283 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#ccc;}#mermaid-283 rect.text{fill:none;stroke-width:0;}#mermaid-283 .icon-shape,#mermaid-283 .image-shape{background-color:hsl(0, 0%, 34.4117647059%);text-align:center;}#mermaid-283 .icon-shape p,#mermaid-283 .image-shape p{background-color:hsl(0, 0%, 34.4117647059%);padding:2px;}#mermaid-283 .icon-shape rect,#mermaid-283 .image-shape rect{opacity:0.5;background-color:hsl(0, 0%, 34.4117647059%);fill:hsl(0, 0%, 34.4117647059%);}#mermaid-283 .label-icon{display:inline-block;height:1em;overflow:visible;vertical-align:-0.125em;}#mermaid-283 .node .label-icon path{fill:currentColor;stroke:revert;stroke-width:revert;}#mermaid-283 :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}

Workerpool

1 . Match compatible orders \\n(request, application, dataset & workerpool orders) \\n & Wait result

2 . Notify new deal with tasks to compute

3 . Request new task to compute

4 . Run application

5.a. Push result

5.b. Commit result proof

6 . Publish result link or callback

Requester (or anyone)

Blockchain

Scheduler

Worker

Application image

Result Storage

tldni

Guaranties about completion times (fast/slow) are available in the [category section](/protocol/pay-per-task):

*   maximum deal/task time
*   maximum computing time

Once the task is completed copy the taskid from `iexec app run` output (taskid is a 32Bytes hexadecimal string).

Download the result of your task

bash

    iexec task show --chain bellecour <taskid> --download my-result

You can get your taskid with the command:

bash

    iexec deal show --chain bellecour <dealid>

INFO

A task result is a zip file containing the output files of the application.

[iexechub/python-hello-world](https://hub.docker.com/repository/docker/iexechub/python-hello-world) produce an text file in `result.txt`.

Let's discover the result of the computation.

bash

    unzip my-result.zip -d my-result
    cat my-result/result.txt

Congratulations! You successfully executed your application on iExec!

Publish your app on the iExec Marketplace [â€‹](#publish-your-app-on-the-iexec-marketplace)
-----------------------------------------------------------------------------------------

Your application is deployed on iExec and you completed an execution on iExec. For now, only you can request an execution of your application. The next step is to publish it on the iExec Marketplace, making it available for anyone to use.

As the owner of this application, you can define the conditions under which it can be used

INFO

iExec uses orders signed by the resource owner's wallet to ensure resources governance.

The conditions to use an app are defined in the **apporder**.

Publish a new apporder for your application.

bash

    iexec app publish --chain bellecour

INFO

`iexec app publish` command allows to define custom access rules to the app (run `iexec app publish --help` to discover all the possibilities).

You will learn more about orders management later, keep the apporder default values for now.

Your application is now available for everyone on iExec marketplace on the conditions defined in apporder.

You can check the published apporders for your app

bash

    iexec orderbook app --chain bellecour <your app address>

Congratulation you just created a decentralized application! Anyone can now trigger an execution of your application on the iExec decentralized infrastructure.

Next step? [â€‹](#next-step)
--------------------------

In this tutorial, you learned how to leverage your app with the power of Trusted Execution Environments using iExec. But according to your use case, you may need to use some confidential data to get the full potential of the **Confidential Computing** paradigm. Check out next chapters to see how:

*   [Access confidential assets from your iApp](./access-confidential-assets)
*   [Protect the result](/guides/build-iapp/advanced/protect-the-result)

Protect the result [â€‹](#protect-the-result)
===========================================

Previous tutorials showed how to build [Confidential Computing applications](/protocol/tee/intel-sgx) that run securely inside enclaves and combine them with confidential assets to get the most out of confidential computing advantages. This chapter pushes things further to protect the workflow in an end to end mode. That means the next step would be encrypting results.

WARNING

Before going any further, make sure you managed to [Build your first application with Scone framework](/guides/build-iapp/advanced/build-your-first-sgx-iapp).

Prerequisites:

*   [Docker](https://docs.docker.com/install/) 17.05 or higher on the daemon and client.
*   [iExec SDK](https://www.npmjs.com/package/iexec) 8.0.0 or higher.
*   Familiarity with the basic concepts of [IntelÂ® SGX](/protocol/tee/intel-sgx) and [SCONE](https://scontain.com) framework.

INFO

You don't need to change your application's code or redeploy it to add this feature.

Assuming your application is deployed (if not please check how to do it [with Scone](/guides/build-iapp/advanced/build-your-first-sgx-iapp#deploy-the-tee-app-on-iexec)), before triggering an execution you need to generate an RSA key-pair, then push the public key to the [Secret Management Service](/protocol/tee/intel-sgx). The latter, in turn, will provide it, at runtime, to the enclave running your Confidential Computing application.

To generate the key-pair, go to `~/iexec-projects` and use the following SDK command:

Make sure your [`chain.json`](/guides/build-iapp/advanced/build-your-first-sgx-iapp#update-chain-json) content is correct.

bash

    iexec result generate-encryption-keypair

This generates two files in `.secrets/beneficiary/`. Make sure to back up the private key in the file `<0x-your-wallet-address>_key`.

bash

    .secrets
    â”œâ”€â”€ beneficiary
    â”‚   â”œâ”€â”€ <0x-you-wallet-address>_key
    â”‚   â””â”€â”€ <0x-you-wallet-address>_key.pub
    ...

Now, push the public key to the SMS:

bash

    iexec result push-encryption-key --tee-framework --chain bellecour scone

And check it using:

bash

    iexec result check-encryption-key --tee-framework --chain bellecour scone

Now to see that in action, you'd need to trigger a task and specify yourself as the beneficiary in the command:

bash

    iexec app run <0x-your-app-address> \
        --chain bellecour
        --workerpool prod-v8-bellecour.main.pools.iexec.eth \
        --tag tee,scone \
        --encrypt-result \
        --watch

Wait for the task to be `COMPLETED` and download the result:

bash

    iexec task show --chain bellecour <0x-your-task-id> --download

If you extract the obtained zip and try to read the content of the file `iexec_out/result.zip.aes` you will find it encrypted:

bash

    mkdir /tmp/trash && \
        unzip <0x-your-task-id>.zip -d /tmp/trash && \
        cat /tmp/trash/iexec_out/result.zip.aes

`iexec_out/result.zip` :

bash

    )î«­3XqYvÈ¿zEfRu<\Ýµmmç–žrc(a{{'Ü¼Í›q/[{Ht>hgD$g\.kj"s?"hJ_Q41_[{XÔšaè˜ŸvErè‚½
    Õ…]9WTL*
              tdzO`!e&snoL3K6L9%

Now you should decrypt the result by running:

bash

    iexec result decrypt <0x-your-task-id.zip>

A new zip file appears in the current folder under the name `results.zip`. Eventually, unzip it:

bash

    unzip results.zip -d my-decrypted-result

And you can see the content of your result file:

bash

    $ cat my-decrypted-result/result.txt
    Hello, world!

VoilÃ ! By finishing this part, you should be able to use confidential computing on iExec like a Ninja. All parts of the workflow are protected: the execution, the dataset, and the result.

You can go to the advanced section and learn more about managing orders on the iExec to effectively monetize your applications and datasets.

Result callback [â€‹](#result-callback)
=====================================

This guide explains how to trigger a callback function at the end of a successful task on your smart contract.

Use a callback when your smart contract should:

*   Ingest off-chain computed data (API aggregation, ML inference, analytics) and persist it
*   React to an execution outcome (conditional trigger, state transition)
*   Store a timestamped record (price feed, score, KPI, proof hash)
*   Bridge logic between external systems and on-chain state

High-level flow [â€‹](#high-level-flow)
-------------------------------------

1.  A requester deploys the smart contract that should receive the callback data.
2.  The requester executes an iApp and specifies the callback address.
3.  The iApp writes `${IEXEC_OUT}/computed.json` with a `callback-data` field (ABIâ€‘encoded bytes you crafted).
4.  After the task completes and is validated, the iExec protocol invokes your contractâ€™s `receiveResult(bytes32,bytes)`.
5.  Your contract decodes and processes those bytes if callback data have been provided.

Step-by-step implementation [â€‹](#step-by-step-implementation)
-------------------------------------------------------------

### Step 1: Implement the callback contract [â€‹](#step-1-implement-the-callback-contract)

Your contract must expose the function `receiveResult(bytes32,bytes)`[ERC1154](https://github.com/iExecBlockchainComputing/iexec-solidity/blob/master/contracts/ERC1154/IERC1154.sol). The protocol calls it with:

*   `_callID`: This parameter represents the `taskId`, passed as the first argument
*   `callback`: exactly the bytes you encoded as `callback-data`

Decode using the same tuple. (Optional) Add protections: authorized caller check (iExec hub / proxy), replay guard, bounds checks.

solidity

    contract IExecCallbackReceiver {
        // Your business logic here ...
    
        // ERC1154 - Callback processing
        function receiveResult(bytes32 _callID, bytes memory callback) external {
            // Parse results
            (uint256 timestamp, string memory pairAndPrecision, uint256 scaledValue) =
                abi.decode(callback, (uint256, string, uint256));
        }
    }

Important

The callback transaction is subject to a maximum gas limit of 200,000 enforced by the protocol.  
Ensure your callback logic fits within this limit to avoid out-of-gas errors.

### Step 2: Prepare the callback payload in the iApp [â€‹](#step-2-prepare-the-callback-payload-in-the-iapp)

You only need to write `computed.json` containing the key `callback-data`.  
That value must be the ABIâ€‘encoded bytes your contract knows how to decode.  
Example tuple schema we'll use: `(uint256 timestamp, string pairAndPrecision, uint256 scaledValue)`.

ts

    
    async function main() {
      // Your business logic here ...
    
      const abiCoder = new AbiCoder();
      const abiPayload = abiCoder.encode(
        ['uint256', 'string', 'uint256'],
        [timestamp, pair, scaled]
      );
    
      writeFileSync(
        `${process.env.IEXEC_OUT}/computed.json`,
        JSON.stringify({
          'callback-data': abiPayload,
        })
      );
    }

### Step 3: Run the iApp with a callback [â€‹](#step-3-run-the-iapp-with-a-callback)

When creating the request order, set the `callback` field to your callback contract address.  
After completion, the protocol calls your contract, passing the `callback-data` bytes.

First install the iExec SDK if you have not already (see the [iExec SDK documentation](/references/sdk)).

ts

    // Basic arguments
    const requestorderToSign = await iexec.order.createRequestorder({
      app: '0x456def...',
      category: 0,
      appmaxprice: 10,
      workerpool: '0xa5de76...',
      callback: '0x8e5bB6...', // Callback contract address
    });
    const requestOrder = await iexec.order.signRequestorder(requestorderToSign);
    
    // Fetch app orders
    const appOrders = await iexec.orderbook.fetchAppOrderbook(
      '0x456def...' // Filter by specific app
    );
    if (appOrders.orders.length === 0) {
      throw new Error('No app orders found for the specified app');
    }
    
    // Fetch workerpool orders
    const workerpoolOrders = await iexec.orderbook.fetchWorkerpoolOrderbook({
      workerpool: '0xa5de76...', // Filter by specific workerpool
    });
    if (workerpoolOrders.orders.length === 0) {
      throw new Error('No workerpool orders found for the specified workerpool');
    }
    
    // Execute the task
    const taskId = await iexec.order.matchOrders({
      requestorder: requestOrder,
      apporder: appOrders.orders[0].order,
      workerpoolorder: workerpoolOrders.orders[0].order,
    });

Other use cases [â€‹](#other-use-cases)
-------------------------------------

Use Case

Description

Price oracle

Multi-source API aggregation

Reputation / scoring

Off-chain ML / analytics pushed on-chain

Audit hash

Security scan or verification artifact

Automation

Workflow step completion signal

Dynamic parameters

Adjust rates / thresholds / quorums

Logical bridge

Sync external (IoT / legacy) state

Access confidential assets from your iApp [â€‹](#access-confidential-assets-from-your-iapp)
=========================================================================================

WARNING

Before going any further, make sure you managed to [Build your first iApp with Scone framework](./build-your-first-sgx-iapp).

Secret Management Service (SMS) [â€‹](#secret-management-service-sms)
-------------------------------------------------------------------

You can use confidential assets on iExec thanks to the _iExec Secret Management Service_. This service verifies that the enclave asking for secrets is authorized to do so. Any user - as a confidential asset provider - declares on the blockchain which enclaves are authorized to access it. For each task, the SMS will query the blockchain to determine if the enclave requesting secrets is indeed whitelisted for it.

The SMS currently supports 3 types of secrets:

1.  [App developer secret](/guides/build-iapp/build-&-test#application-developer-secret): This secret is directly accessible from the app as an environment variable. It is owned by the developer of the app. It can be any kind of data (API key, private key, token, ..) as long as it respects the size limit (max. 4096 kB).
2.  [Requester secrets](/guides/build-iapp/inputs#access-requester-secrets): These secrets are directly accessible from the app as environment variables, as long as the requester has decided to share them with it. These secrets can be any kind of data as long as they respect the size limit (max. 4096 kB). Before buying a task, a requester secret is pushed into the SMS and is not linked to any app. When a requester buys a task, the requester can declare which secrets can be accessed by the app. Doing so, a single requester secret can be shared with multiple apps.
3.  [Protected Data secret](/guides/manage-data/manage-access): A protected data secret is not directly accessible from the app but its decrypted content is. If a Protected Data is requested and authorized to be used in it, its content will be automatically decrypted in the app enclave.

Here is a general overview of how iExec uses confidential assets:

Next step? [â€‹](#next-step)
--------------------------

You now understand how these three kinds of confidential assets work on iExec, you can go one step further by learning how to manipulate them:

*   [Access to a Protected Data](/guides/build-iapp/inputs#protected-data)

Build Intel TDX iApp [â€‹](#build-intel-tdx-iapp)
===============================================

In this tutorial, you will learn how to build and run a Confidential Computing application with Intel TDX technology using both traditional deployment and the iApp Generator.

**Experimental Feature**

TDX support is currently in experimental phase:

*   Stability and confidentiality features are still being tested and refined.
*   Features may evolve based on user feedback, please share your experience on [Discord](https://discord.com/invite/5TewNUnJHN).

Before implementing TDX, make sure you understand the foundational concepts and differences between TEE technologies. Check out our **[Intel TDX Technology](/protocol/tee/intel-tdx)** guide for comprehensive explanations of TDX technology and its benefits.

Prerequisites [â€‹](#prerequisites)
---------------------------------

*   [Docker](https://docs.docker.com/install/) 17.05 or higher on the daemon and client.
*   [iExec SDK 8.13.0-tdx](https://github.com/aimen-djari/iexec-sdk/tree/feature/tdx). Contact us to have this special release.

Choose Your Approach [â€‹](#choose-your-approach)
-----------------------------------------------

This tutorial covers two methods for building TDX applications:

1.  **[Traditional Deployment](#build-your-application)** - Manual configuration with `chain.json` and `iexec.json`
2.  **[iApp Generator](#using-iapp-generator)** - Simplified deployment using the iApp Generator tool

Build your application [â€‹](#build-your-application)
---------------------------------------------------

Thanks to **Intel TDX**, neither the source code or the binaries of your application need to be changed in order to run securely in a TEE. Only two files need to be changed compared to the usual SGX workflow: `chain.json` and `iexec.json`.

iApp using Intel TDX technology follow the same format as non-TEE applications; follow the instructions on [Build your first application](/guides/build-iapp/advanced/build-your-first-sgx-iapp) to create and Dockerize your iApp.

After this step, the Docker image of your iApp should be published on Docker Hub (e.g. `<docker-hub-user>/hello-world:1.0.0`).

### Update `chain.json` [â€‹](#update-chain-json)

Modify your `chain.json` as follows to reference the TDX Workerpool:

json

    {
      "default": "bellecour",
      "chains": {
        "bellecour": {
          "sms": { "tdx": "https://sms.labs.iex.ec" }
        }
      }
    }

### Update `iexec.json` [â€‹](#update-iexec-json)

TEE applications need a few more keys in the `iexec.json` file; run this to add them automatically:

bash

    iexec app init --tee-framework tdx

Your `iexec.json` should now look like this example:

json

    {
      ...
      "app": {
        "owner": "<your-wallet-address>", // starts with 0x
        "name": "tee-scone-hello-world", // application name
        "type": "DOCKER",
        "multiaddr": "<docker-hub-user>/hello-world:1.0.0", // app image
        "checksum": "<checksum>", // starts with 0x, update it with your own image digest
        "mrenclave": {
          "framework": "TDX", // TEE framework (keep default value)
       }
      },
      ...
    }

INFO

See [Deploy your iApp on iExec](/guides/build-iapp/deploy-&-run) to retrieve your image `<checksum>`.

### Deploy and run the TEE iApp [â€‹](#deploy-and-run-the-tee-iapp)

Deploy the iApp with the standard command:

bash

    iexec app deploy

To execute the iApp in TDX, add `--tag tee,tdx` to the `iexec app run` and select the TDX workerpool (`tdx-labs.pools.iexec.eth`).

bash

    iexec app run --tag tee,tdx --workerpool tdx-labs.pools.iexec.eth --watch

INFO

Remember, you can access task and iApp logs by following the instructions on page [Debug your tasks](/guides/build-iapp/debugging).

Using iApp Generator [â€‹](#using-iapp-generator)
-----------------------------------------------

The iApp Generator provides a simplified way to deploy and run TDX applications with minimal configuration.

### Enabling TDX in iApp Generator [â€‹](#enabling-tdx-in-iapp-generator)

#### Environment Variable Method [â€‹](#environment-variable-method)

**Enable TDX for deployment and execution**:

bash

    # Set the experimental flag
    export EXPERIMENTAL_TDX_APP=true
    
    # Deploy and run with TDX
    iapp deploy
    iapp run <app-address>

Environment Variable Declaration

The syntax for setting environment variables differs between operating systems:

*   **Mac/Linux**: `export EXPERIMENTAL_TDX_APP=true`
*   **Windows**: `set EXPERIMENTAL_TDX_APP=true`

#### Per-Command Method [â€‹](#per-command-method)

**Enable TDX for specific commands**:

bash

    # Deploy TDX-enabled iApp
    EXPERIMENTAL_TDX_APP=true iapp deploy
    
    # Run with TDX
    EXPERIMENTAL_TDX_APP=true iapp run <app-address>
    
    # Debug TDX execution
    EXPERIMENTAL_TDX_APP=true iapp debug <taskId>

#### Verification [â€‹](#verification)

**Check if TDX is enabled**:

bash

    # Your deployed iApp should show TDX-related tags
    iexec app show <app-address>

### DataProtector SDK Configuration [â€‹](#dataprotector-sdk-configuration)

âš ï¸ **To use** the iExec DataProtector SDK with TDX support, you must configure the SDK with the right SMS endpoint.

jsx

    const dataProtector = new IExecDataProtector(web3Provider, {
      iexecOptions: {
        smsURL: 'https://sms.labs.iex.ec',
      },
    });

âš ï¸**You need** to change the default worker pool in your protected Data declaration

jsx

    await dataProtector.core.processProtectedData({
      protectedData: protectedData.address,
      workerpool: 'tdx-labs.pools.iexec.eth',
      app: '0x456def...',
    });

### Protected Data Compatibility [â€‹](#protected-data-compatibility)

Protected Data Requirements

**TDX iApp may require TDX-compatible protected data.** Check compatibility before using protected data with TDX iApp.

**Important**: The exact process for creating TDX-compatible protected data may differ from standard protected data creation. Consult the latest DataProtector documentation for TDX-specific requirements.

### Development Workflow [â€‹](#development-workflow)

#### 1\. **Local Testing** [â€‹](#_1-local-testing)

bash

    # Test locally (same as regular iApp)
    iapp test --protectedData "mock_name"
    
    # TDX only affects remote deployment/execution

#### 2\. **Deployment** [â€‹](#_2-deployment)

bash

    # Deploy TDX iApp
    EXPERIMENTAL_TDX_APP=true iapp deploy

#### 3\. **Execution** [â€‹](#_3-execution)

bash

    # Run with TDX
    EXPERIMENTAL_TDX_APP=true iapp run <app-address>

Current Limitations [â€‹](#current-limitations)
---------------------------------------------

Production Warnings

*   **ðŸš« NOT for production use**
*   **ðŸš« Limited worker availability**
*   **ðŸš« Unstable execution** environment
*   **ðŸš« Breaking changes** without notice

What's Next? [â€‹](#what-s-next)
------------------------------

### **Continue with TDX Development** [â€‹](#continue-with-tdx-development)

**Enhance your TDX application**:

*   **[Debugging Your iApp](/guides/build-iapp/debugging)** - Troubleshoot execution issues and TDX-specific problems
*   **[Inputs](/guides/build-iapp/inputs)** - Handle data inputs
*   **[Outputs](/guides/build-iapp/outputs)** - Handle data outputs in TEE environment with TDX
*   **[iApp Access Control and Pricing](/guides/build-iapp/manage-access)** - Configure access control for your TDX applications

### **Learn More About TEE Technologies** [â€‹](#learn-more-about-tee-technologies)

**Deepen your understanding**:

*   **[Intel TDX Technology](/protocol/tee/intel-tdx)** - Comprehensive guide to TDX technology and benefits
*   **[SGX vs TDX Comparison](/protocol/tee/sgx-vs-tdx)** - Understand the differences between TEE technologies
*   **[Introduction to TEE Technologies](/protocol/tee/introduction)** - Foundation concepts of TEE technologies

### **Production Considerations** [â€‹](#production-considerations)

**For production applications**:

*   **âš ï¸ TDX is experimental**: Consider using **[Intel SGX Technology](/protocol/tee/intel-sgx)** for production
*   **[Create Your First SGX iApp](/guides/build-iapp/advanced/build-your-first-sgx-iapp)** - Build production-ready SGX applications
*   **[Deploy & Run](/guides/build-iapp/deploy-&-run)** - Standard iApp deployment guide

### **Related Resources** [â€‹](#related-resources)

**Explore the iExec ecosystem**:

*   **[iApp Generator Reference](/references/iapp-generator)** - Complete iApp Generator documentation
*   **[DataProtector SDK](/references/dataProtector)** - Work with protected data in TDX
*   **[Advanced iApp Building](/guides/build-iapp/advanced/quick-start)** - Advanced development techniques

How to Pay for iApp Executions [â€‹](#how-to-pay-for-iapp-executions)
===================================================================

iExec uses RLC tokens as the native currency for executing iApps. This guide covers how to acquire RLC, stake it on the protocol, and manage execution costs.

Getting RLC Tokens [â€‹](#getting-rlc-tokens)
-------------------------------------------

To execute iApps, you need RLC tokens in your wallet. For detailed information on how to obtain RLC tokens, see our [RLC guide](/get-started/overview/rlc).

Staking RLC [â€‹](#staking-rlc)
-----------------------------

RLC tokens need to be staked on the iExec protocol to allow task payment. Use the [iExec SDK](/references/sdk) to deposit and manage your RLC:

ts

    // Check your balance
    const balance = await iexec.account.checkBalance('0xa0c15e...');
    console.log('Nano RLC staked:', balance.stake.toString());
    console.log('Nano RLC locked:', balance.locked.toString());
    
    // Lock RLC in your account in the iExec protocol
    await iexec.account.deposit(1_000_000_000); // Deposit 1 RLC

Now you are ready to run a task on the iExec Protocol and pay for it. See our guide on [running iApp with ProtectedData](/guides/use-iapp/run-iapp-with-ProtectedData) for detailed execution steps.

Understanding Pricing [â€‹](#understanding-pricing)
-------------------------------------------------

### Cost components [â€‹](#cost-components)

iApp execution costs consist of several components:

1.  **Application Fee**: Paid to the app developer
2.  **Data Fee**: Paid to the data owner (if using protected data)
3.  **Workerpool Fee**: Paid to the computation provider
4.  **Gas Fees**: Blockchain transaction costs

### Setting maximum prices [â€‹](#setting-maximum-prices)

You can control costs by setting maximum prices for each component:

ts

    const result = await dataProtectorCore.processProtectedData({
      protectedData: '0x123abc...',
      app: '0x456def...',
      dataMaxPrice: 5, // Maximum amount (in nRLC) to pay the protected data owner
      appMaxPrice: 3, // Maximum amount (in nRLC) to pay the iApp provider
      workerpoolMaxPrice: 2, // Maximum amount (in nRLC) to pay the workerpool provider
    });

INFO

All price parameters are in nRLC (nano RLC). The default value for all price parameters is 0, which means only free resources are accepted.

Next Steps [â€‹](#next-steps)
---------------------------

Now that you know how to pay for iApp executions:

*   [Run iApp with ProtectedData](/guides/use-iapp/run-iapp-with-ProtectedData)
*   [Run iApp without ProtectedData](/guides/use-iapp/run-iapp-without-ProtectedData)

Run iApp with a ProtectedData [â€‹](#run-iapp-with-a-protecteddata)
=================================================================

When running an iApp, you can use multiple types of inputs. While ProtectedData is not mandatory to run an iApp, it's a powerful input type that allows you to process encrypted data from another provider. You can also use non-persistent inputs that come directly from you (the requester) and can change between each execution: Arguments, Input Files, and Secrets. These non-persistent inputs are perfect for customizing the iApp's behavior for each specific run.

Prerequisites [â€‹](#prerequisites)
---------------------------------

First, install DataProtector in your project (for more details see [DataProtector Getting Started](/references/dataProtector/getting-started)):

npmyarnpnpmbun

bash

    npm install @iexec/dataprotector

bash

    yarn add @iexec/dataprotector

bash

    pnpm add @iexec/dataprotector

bash

    bun add @iexec/dataprotector

Adding Protected Data [â€‹](#adding-protected-data)
-------------------------------------------------

When working with protected data that contains multiple files, you can specify which file to process.

ts

    // Process protected data with specific path
    const result = await dataProtectorCore.processProtectedData({
      protectedData: '0x123abc...',
      app: '0x456def...',
      path: 'data/input.csv',
    });

The `processProtectedData` function will automatically download and decrypt the results for you. Nevertheless, if you want to retrieve results from a completed task, you can do so as follows:

ts

    // Retrieve the result
    const taskResult = await dataProtectorCore.getResultFromCompletedTask({
      taskId: taskId,
    });

Adding Command-Line Arguments [â€‹](#adding-command-line-arguments)
-----------------------------------------------------------------

Command-line arguments are passed as a string to the iApp and are visible on the blockchain.

ts

    // Process protected data with arguments
    const result = await dataProtectorCore.processProtectedData({
      protectedData: '0x123abc...',
      app: '0x456def...',
      args: '--input-path data/input.csv --output-format json --verbose',
    });

Adding Input Files [â€‹](#adding-input-files)
-------------------------------------------

Input files are URLs to public files that the iApp can download during execution.

ts

    // Process protected data with input files
    const result = await dataProtectorCore.processProtectedData({
      protectedData: '0x123abc...',
      app: '0x456def...',
      inputFiles: [
        'https://raw.githubusercontent.com/user/repo/main/config.json',
        'https://example.com/public-data.csv',
      ],
    });

Adding Secrets [â€‹](#adding-secrets)
-----------------------------------

Secrets are sensitive data like API keys, passwords, or tokens that are stored securely and made available to the iApp as environment variables.

ts

    // Process protected data with secrets
    const result = await dataProtectorCore.processProtectedData({
      protectedData: '0x123abc...',
      app: '0x456def...',
      secrets: {
        1: 'openai-api-key',
        2: 'database-password',
      },
    });

    Run iApp without a ProtectedData [â€‹](#run-iapp-without-a-protecteddata)
=======================================================================

When running an iApp, you can use multiple types of inputs even without ProtectedData. Non-persistent inputs come directly from you (the requester) and can change between each execution, making them perfect for customizing the iApp's behavior for each specific run. These inputs include Arguments, Input Files, and Secrets, which allow you to provide additional data, parameters, and configuration to enable processing and customize functionality.

Prerequisites [â€‹](#prerequisites)
---------------------------------

First, install iExec SDK in your project (for more details see [iExec SDK documentation](/references/sdk)):

npmyarnpnpmbun

sh

    npm install iexec

sh

    yarn add iexec

sh

    pnpm add iexec

sh

    bun add iexec

Adding Command-Line Arguments [â€‹](#adding-command-line-arguments)
-----------------------------------------------------------------

Command-line arguments are passed as a string to the iApp and are visible on the blockchain.

ts

    // Basic arguments
    const requestorderToSign = await iexec.order.createRequestorder({
      app: '0x456def...',
      category: 0,
      appmaxprice: 10,
      workerpool: '0xa5de76...',
      params: 'arg1 arg2 arg3', // Command-line arguments
      // Other parameters have default values
    });
    const requestOrder = await iexec.order.signRequestorder(requestorderToSign);
    
    // Fetch app orders
    const appOrders = await iexec.orderbook.fetchAppOrderbook(
      '0x456def...' // Filter by specific app
    );
    if (appOrders.orders.length === 0) {
      throw new Error('No app orders found for the specified app');
    }
    
    // Fetch workerpool orders
    const workerpoolOrders = await iexec.orderbook.fetchWorkerpoolOrderbook({
      workerpool: '0xa5de76...', // Filter by specific workerpool
    });
    if (workerpoolOrders.orders.length === 0) {
      throw new Error('No workerpool orders found for the specified workerpool');
    }
    
    // Execute the task
    const taskId = await iexec.order.matchOrders({
      requestorder: requestOrder,
      apporder: appOrders.orders[0].order,
      workerpoolorder: workerpoolOrders.orders[0].order,
    });

Adding Input Files [â€‹](#adding-input-files)
-------------------------------------------

Input files are URLs to public files that the iApp can download during execution.

ts

    // Single input file
    const requestorderToSign = await iexec.order.createRequestorder({
      app: '0x456def...',
      category: 0, // Required: category for the request
      appmaxprice: 10,
      workerpool: '0xa5de76...',
      params: {
        iexec_input_files: [
          'https://example.com/config.json',
          'https://example.com/template.html',
          'https://example.com/data.csv',
        ],
      },
    });
    const requestOrder = await iexec.order.signRequestorder(requestorderToSign);
    
    // Fetch app orders
    const appOrders = await iexec.orderbook.fetchAppOrderbook(
      '0x456def...' // Filter by specific app
    );
    if (appOrders.orders.length === 0) {
      throw new Error('No app orders found for the specified app');
    }
    
    // Fetch workerpool orders
    const workerpoolOrders = await iexec.orderbook.fetchWorkerpoolOrderbook({
      workerpool: '0xa5de76...', // Filter by specific workerpool
    });
    if (workerpoolOrders.orders.length === 0) {
      throw new Error('No workerpool orders found for the specified workerpool');
    }
    
    // Execute the task
    const taskId = await iexec.order.matchOrders({
      requestorder: requestOrder,
      apporder: appOrders.orders[0].order,
      workerpoolorder: workerpoolOrders.orders[0].order,
    });

Adding Secrets [â€‹](#adding-secrets)
-----------------------------------

Secrets are sensitive data like API keys, passwords, or tokens that are stored securely and made available to the iApp as environment variables.

Browser

ts

    // Basic secrets
    const requestorderToSign = await iexec.order.createRequestorder({
      app: '0x456def...',
      category: 0, // Required: category for the request
      appmaxprice: 10,
      workerpool: '0xa5de76...',
      params: {
        iexec_secrets: {
          1: 'api-key-12345',
          2: 'database-password',
        },
      },
    });
    const requestOrder = await iexec.order.signRequestorder(requestorderToSign);
    
    // Fetch app orders
    const appOrders = await iexec.orderbook.fetchAppOrderbook(
      '0x456def...' // Filter by specific app
    );
    if (appOrders.orders.length === 0) {
      throw new Error('No app orders found for the specified app');
    }
    
    // Fetch workerpool orders
    const workerpoolOrders = await iexec.orderbook.fetchWorkerpoolOrderbook({
      workerpool: '0xa5de76...', // Filter by specific workerpool
    });
    if (workerpoolOrders.orders.length === 0) {
      throw new Error('No workerpool orders found for the specified workerpool');
    }
    
    // Execute the task
    const taskId = await iexec.order.matchOrders({
      requestorder: requestOrder,
      apporder: appOrders.orders[0].order,
      workerpoolorder: workerpoolOrders.orders[0].order,
    });

    Integrate Web3 Messaging [â€‹](#integrate-web3-messaging)
=======================================================

This guide covers both Web3Mail (email) and Web3Telegram (Telegram) toolkit. The flow is the same, except that:

*   For Web3Mail, you only need the user's email address.
*   For Web3Telegram, you only need the user's Telegram Chat ID.

Overview [â€‹](#overview)
-----------------------

1.  (Telegram only) Get a Chat ID from the iExec bot
2.  Create the Protected Data using DataProtector Toolkit
3.  Grant access of your Protected Data
4.  Send the message using the relevant SDK (Web3Mail / Web3Telegram)

You can send messages in two modes: single messages (one recipient at a time) or bulk campaigns (same message to multiple recipients efficiently). See step 4 below for details.

1\. Retrieve the Telegram Chat ID (Telegram only) [â€‹](#_1-retrieve-the-telegram-chat-id-telegram-only)
------------------------------------------------------------------------------------------------------

Ask the recipient to open Telegram and start a conversation with [@IExecWeb3TelegramBot](https://t.me/IExecWeb3TelegramBot). The bot replies with a unique Chat ID.

TIP

*   Once the Chat ID is protected, all messages will arrive within this bot conversation.
*   The recipient can leave the conversation at any time to stop receiving messages.

2\. Create the Protected Data [â€‹](#_2-create-the-protected-data)
----------------------------------------------------------------

Protect the email address or Chat ID using DataProtector Core.

Web3MailWeb3Telegram

ts

    import { IExecDataProtectorCore, getWeb3Provider } from '@iexec/dataprotector';
    const web3Provider = getWeb3Provider('PRIVATE_KEY');
    const dataProtectorCore = new IExecDataProtectorCore(web3Provider);
    
    const protectedData = await dataProtectorCore.protectData({
      data: {
        email: 'user@example.com',
      },
    });

ts

    import { IExecDataProtectorCore, getWeb3Provider } from '@iexec/dataprotector';
    const web3Provider = getWeb3Provider('PRIVATE_KEY');
    const dataProtectorCore = new IExecDataProtectorCore(web3Provider);
    
    const protectedData = await dataProtectorCore.protectData({
      data: {
        telegram_chatId: '12345678',
      },
    });

3\. Grant Access [â€‹](#_3-grant-access)
--------------------------------------

Grant permission for a sender and/or an app to contact the user. Choose the mode based on your use case: use **Single Message** mode for individual messages, or **Bulk Campaigns** mode for sending the same message to multiple recipients.

Single MessageBulk Campaigns

ts

    import { IExecDataProtectorCore, getWeb3Provider } from '@iexec/dataprotector';
    const web3Provider = getWeb3Provider('PRIVATE_KEY');
    const dataProtectorCore = new IExecDataProtectorCore(web3Provider);
    
    const grantedAccess = await dataProtectorCore.grantAccess({
      protectedData: '0x123abc...',
      authorizedApp: '0x456def...',
      authorizedUser: '0x789cba...',
      pricePerAccess: 3,
      numberOfAccess: 10,
    });

ts

    // allowBulk: true automatically sets pricePerAccess to 0 and numberOfAccess to unlimited
    const grantedAccess = await dataProtectorCore.grantAccess({
      protectedData: '0x123abc...',
      authorizedApp: '0x456def...',
      authorizedUser: '0x789cba...',
      allowBulk: true, 
    });

4\. Send the Message [â€‹](#_4-send-the-message)
----------------------------------------------

### Single Messages [â€‹](#single-messages)

Send a message to a single recipient:

Web3Mail - SingleWeb3Telegram - Single

ts

    import { IExecWeb3mail, getWeb3Provider } from '@iexec/web3mail';
    
    const web3Provider = getWeb3Provider('PRIVATE_KEY');
    const web3mail = new IExecWeb3mail(web3Provider);
    
    const sendEmail = await web3mail.sendEmail({
      protectedData: '0x123abc...',
      emailSubject: 'My email subject',
      emailContent: 'My email content',
    });

ts

    import { IExecWeb3telegram, getWeb3Provider } from '@iexec/web3telegram';
    
    const web3Provider = getWeb3Provider('PRIVATE_KEY');
    const web3telegram = new IExecWeb3telegram(web3Provider);
    
    const sendTelegram = await web3telegram.sendTelegram({
      protectedData: '0x123abc...',
      senderName: 'Arthur',
      telegramContent: 'My telegram message content',
    });

### Bulk Campaigns [â€‹](#bulk-campaigns)

Send the same message to multiple recipients efficiently. Bulk processing groups multiple protected data items (emails for Web3Mail or chat IDs for Web3Telegram) together, reducing gas fees and processing recipients in parallel across one or more transactions.

**To send a bulk campaign, follow these steps in order:**

1.  **Fetch contacts** with bulk access capability using `fetchMyContacts` or `fetchUserContacts` with `bulkOnly: true`
2.  **Prepare the campaign** by calling `prepareEmailCampaign` (for Web3Mail) or `prepareTelegramCampaign` (for Web3Telegram). This creates a bulk request object that groups all recipients together
3.  **Send the campaign** by calling `sendEmailCampaign` (for Web3Mail) or `sendTelegramCampaign` (for Web3Telegram) with the prepared bulk request

Prerequisites

Before using bulk processing, ensure that recipients have granted access with `allowBulk: true` when calling `grantAccess` (see step 3 above).

Web3Mail - BulkWeb3Telegram - Bulk

ts

    import { IExecDataProtectorCore, getWeb3Provider } from '@iexec/dataprotector';
    import { IExecWeb3mail } from '@iexec/web3mail';
    
    const web3Provider = getWeb3Provider('PRIVATE_KEY');
    const dataProtectorCore = new IExecDataProtectorCore(web3Provider);
    const web3mail = new IExecWeb3mail(web3Provider);
    
    // Steps 1-2: Executed by the recipient (protected data provider)
    // Step 1: Create Protected Data (see section 2)
    const protectedData = await dataProtectorCore.protectData({
      data: {
        email: 'user@example.com',
      },
    });
    
    // Step 2: Grant access with bulk processing enabled (see section 3)
    const grantedAccess = await dataProtectorCore.grantAccess({
      protectedData: protectedData.address,
      authorizedApp: '0x456def...',
      authorizedUser: '0x789cba...',
      allowBulk: true,
    });
    
    // Steps 3-5: Executed by the sender (who wants to contact recipients)
    // Step 3: Fetch contacts with bulk access
    const contacts = await web3mail.fetchMyContacts({ bulkOnly: true });
    const grantedAccessArray = contacts.map((contact) => contact.grantedAccess);
    
    // Step 4: Prepare the campaign
    const emailCampaign = await web3mail.prepareEmailCampaign({
      grantedAccesses: grantedAccessArray,
      emailSubject: 'Hello from My Awesome App!',
      emailContent: 'Hello! This is a bulk email sent to all recipients.',
      contentType: 'text/html',
    });
    
    // Step 5: Send the bulk campaign
    const { tasks } = await web3mail.sendEmailCampaign({
      campaignRequest: emailCampaign.campaignRequest,
    });

ts

    import { IExecDataProtectorCore, getWeb3Provider } from '@iexec/dataprotector';
    import { IExecWeb3telegram } from '@iexec/web3telegram';
    
    const web3Provider = getWeb3Provider('PRIVATE_KEY');
    const dataProtectorCore = new IExecDataProtectorCore(web3Provider);
    const web3telegram = new IExecWeb3telegram(web3Provider);
    
    // Steps 1-2: Executed by the recipient (protected data provider)
    // Step 1: Create Protected Data (see section 2)
    const protectedData = await dataProtectorCore.protectData({
      data: {
        telegram_chatId: '12345678',
      },
    });
    
    // Step 2: Grant access with bulk processing enabled (see section 3)
    const grantedAccess = await dataProtectorCore.grantAccess({
      protectedData: protectedData.address,
      authorizedApp: '0x456def...',
      authorizedUser: '0x789cba...',
      allowBulk: true,
    });
    
    // Steps 3-5: Executed by the sender (who wants to contact recipients)
    // Step 3: Fetch contacts with bulk access
    const contacts = await web3telegram.fetchMyContacts({ bulkOnly: true });
    const grantedAccessArray = contacts.map((contact) => contact.grantedAccess);
    
    // Step 4: Prepare the campaign
    const telegramCampaign = await web3telegram.prepareTelegramCampaign({
      grantedAccesses: grantedAccessArray,
      telegramContent: 'Hello! This is a bulk message sent to all recipients.',
      senderName: 'My Awesome App',
    });
    
    // Step 5: Send the bulk campaign
    const { tasks } = await web3telegram.sendTelegramCampaign({
      campaignRequest: telegramCampaign.campaignRequest,
    });

Payment [â€‹](#payment)
---------------------

Each message sent through Web3Mail or Web3Telegram requires payment in RLC tokens.

For detailed information about payment methods and pricing, see the comprehensive guide: [How to pay for executions](/guides/use-iapp/how-to-pay-executions)

DataProtector 2.0.0 [â€‹](#dataprotector)
=======================================

DataProtector **simplifies secure data management**, offering users essential tools for protecting, managing, and sharing their data effectively.

DataProtector Core [â€‹](#dataprotector-core)
-------------------------------------------

As the foundational component of DataProtector, DataProtector Core provides essential functionalities for data protection. Users can **encrypt their data** and **record ownership on a smart contract**, ensuring confidentiality and traceability. Granting access to authorized applications is streamlined, facilitating secure data management.

With `DataProtector Core`, you can **grant access** to your protected data **to a specific user**.

*   You define the number of times the user can access the data.
*   You should choose an iApp (iExec TEE Dapp) that will be able to process your protected data.
*   You'll have to sign a transaction at the moment you grant access to the user and the iApp (iExec TEE Dapp).

Getting Started [â€‹](#getting-started)
=====================================

[![GitHub package.json version (branch)](https://img.shields.io/badge/npm-2.0.0--beta-green)](https://www.npmjs.com/package/@iexec/dataprotector)

Overview [â€‹](#overview)
-----------------------

### Prerequisites [â€‹](#prerequisites)

Before getting started, ensure that you have the following installed on your system:

\- [**Node.js**](https://nodejs.org/en/) version 18 or higher

\- [**NPM**](https://docs.npmjs.com/) (Node.js package manager)

### Installation [â€‹](#installation)

npmyarnpnpmbun

sh

    npm install @iexec/dataprotector

sh

    yarn add @iexec/dataprotector

sh

    pnpm add @iexec/dataprotector

sh

    bun add @iexec/dataprotector

**This package is an ESM package. Your project needs to use ESM too.** Â [**Read more**](https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c)

If you use it with **Webpack**, some polyfills will be needed. You can find a minimal working project [here](https://github.com/iExecBlockchainComputing/dataprotector-sdk/tree/115b797cf62dcff0f41e2ba783405d5083d78922/packages/demo/browser-webpack).

### Instantiate SDK [â€‹](#instantiate-sdk)

BrowserNodeJS

ts

    import { IExecDataProtectorCore } from '@iexec/dataprotector';
    
    const web3Provider = window.ethereum;
    // Instantiate only the Core module
    const dataProtectorCore = new IExecDataProtectorCore(web3Provider);

ts

    import { IExecDataProtectorCore, getWeb3Provider } from '@iexec/dataprotector';
    
    // Get Web3 provider from a private key
    const web3Provider = getWeb3Provider('YOUR_PRIVATE_KEY');
    
    // Instantiate the Core module
    const dataProtectorCore = new IExecDataProtectorCore(web3Provider);

#### Instantiate Without a Web3 Provider [â€‹](#instantiate-without-a-web3-provider)

For projects that only require read functions, you can instantiate the SDK without a Web3 provider.

Singleton ModulesUmbrella Module

ts

    import { IExecDataProtectorCore } from '@iexec/dataprotector';
    
    // Instantiate only the Core module for read-only core methods
    const dataProtectorCore = new IExecDataProtectorCore();

ts

    import { IExecDataProtector } from '@iexec/dataprotector';
    
    // Instantiate using the umbrella module for read-only functions
    const dataProtector = new IExecDataProtector();
    
    // Access to read-only core methods
    const dataProtectorCore = dataProtector.core;

#### Advanced Configuration [â€‹](#advanced-configuration)

To add optional parameters, see [advanced configuration](/references/dataProtector/advanced-configuration).

INFO

ðŸ§ª While protected data are processed in **TEE** by **intel SGX** technology by default, `@iexec/dataprotector` can be configured to create and process protected data in the experimental **intel TDX** environment.

For more details see:

*   [process TDX protected data](/references/dataProtector/methods/processProtectedData#workerpool)

âš ï¸ Keep in mind: TDX mode is experimental and can be subject to instabilities or discontinuity.

Sandbox [â€‹](#sandbox)
---------------------

### DataProtector Core

Interactive

Essential data protection features including encryption, access control, and secure storage.

[Open Sandbox](https://codesandbox.io/p/github/iExecBlockchainComputing/dataprotector-sandbox/main) [Sandbox Github](https://github.com/iExecBlockchainComputing/dataprotector-sandbox)

protectData [â€‹](#protectdata)
=============================

The iExec tool suite supports deployment of applications where the user of the application has complete and total control over access to their data. This ensures privacy and security when invoking these applications.

Through use of the `protectData` method, a user may encrypt and secure any type of data. Encryption occurs on the client side, supporting the user's control over their data.

Usage [â€‹](#usage)
-----------------

The method accepts a JSON object containing the data to encrypt and an optional name to identify the data.

An email address, for example, may be submitted as:

ts

    const protectedData = await dataProtectorCore.protectData({
      data: {
        email: 'example@gmail.com',
      },
    });

Your object may contain any number of custom keys. The following example illustrates protection of multiple categories of data within one object:

ts

    const protectedData = await dataProtectorCore.protectData({
      data: {
        email: 'example@gmail.com',
        SMTPserver: {
          port: 5000,
          smtp_server: 'smtp.gmail.com',
        },
      },
    });

INFO

ðŸ§ª While protected data are processed in **TEE** by **intel SGX** technology by default, `@iexec/dataprotector` can be configured to create and process protected data in the experimental **intel TDX** environment.

TDX mode is enabled by setting connecting the **TDX SMS** and using the **TDX workerpool**.

Browser

ts

    import { IExecDataProtectorCore } from '@iexec/dataprotector';
    
    const web3Provider = window.ethereum;
    // Instantiate dataProtector connected to the TDX SMS
    const dataProtectorCore = new IExecDataProtectorCore(web3Provider, {
      iexecOptions: {
        smsURL: 'https://sms.labs.iex.ec', 
      },
    });
    // create a protected data
    const protectedData = await dataProtectorCore.protectData({
      data: {
        email: 'example@gmail.com',
        SMTPserver: {
          port: 5000,
          smtp_server: 'smtp.gmail.com',
        },
      },
    });

âš ï¸ Keep in mind: TDX mode is experimental and can be subject to instabilities or discontinuity.

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type ProtectDataParams } from '@iexec/dataprotector';

### data Required \* [â€‹](#data)

**Type:** `DataObject`

This is the actual data the user is protecting, provided as a JSON object with any number of custom keys. The data is encrypted and stored as an NFT.

ts

    const protectedData = await dataProtectorCore.protectData({
      data: { 
        email: 'example@gmail.com', 
      }, 
    });

TIP

If you'd like to **protect a file**, you first need to convert it to a buffer. You can use `createArrayBufferFromFile` to do this.

ts

    import { createArrayBufferFromFile } from '@iexec/dataprotector';
    
    const fileAsArrayBuffer = await createArrayBufferFromFile(file);

TIP

If you want to **protect an `Array`**, you must represent it as a `Record<string, any>`. To do so, you can use the `reduceArray` method implemented in this example.

ts

    const reduceArray = (array: Array<any>): Record<string, any> =>
      array.reduce((accumulator, current, i) => {
        accumulator[i] = current;
        return accumulator;
      }, {});
    
    const emailsArray = [
      'example@gmail.com',
      'example@my-company.com',
      'example@example.com',
    ];
    
    const protectedData = await dataProtectorCore.protectData({
      data: {
        emails: reduceArray(emailsArray),
      },
    });
    
    /**
     * protectedData.schema:
     * {
     *   emails: {
     *     0: 'string',
     *     1: 'string',
     *     2: 'string'
     *   }
     * }
     */

### name Optional [â€‹](#name)

**Type:** `string`  
**Default:** `''`

Allows providing a descriptive name for the protected data. This is considered public metadata, describing the protected data.

ts

    const protectedData = await dataProtectorCore.protectData({
      name: 'myEmail', 
      data: {
        email: 'example@gmail.com',
      },
    });

TIP

The name is public and not encrypted.

### uploadMode Optional [â€‹](#uploadmode)

**Type:** `"ipfs" | "arweave"`  
**Default:** `"ipfs"`

Specify the storage platform to use for the protected data encrypted payload hosting.

ts

    const protectedData = await dataProtectorCore.protectData({
      name: 'myEmail',
      data: {
        email: 'example@gmail.com',
      },
      uploadMode: 'arweave', 
    });

### onStatusUpdate Optional [â€‹](#onstatusupdate)

**Type:** `OnStatusUpdateFn<ProtectDataStatuses>`

Callback function to be notified at intermediate steps.

ts

    const protectedData = await dataProtectorCore.protectData({
      name: 'myEmail',
      data: {
        email: 'example@gmail.com',
      },
      onStatusUpdate: ({ title, isDone }) => {
        console.log(title, isDone); 
      }, 
    });

You can expect this callback function to be called with the following titles:

ts

    'EXTRACT_DATA_SCHEMA';
    'CREATE_ZIP_FILE';
    'CREATE_ENCRYPTION_KEY';
    'ENCRYPT_FILE';
    'UPLOAD_ENCRYPTED_FILE';
    'DEPLOY_PROTECTED_DATA';
    'PUSH_SECRET_TO_SMS';

Once with `isDone: false`, and then with `isDone: true`

Return Value [â€‹](#return-value)
-------------------------------

ts

    import type {
      ProtectedDataWithSecretProps,
      ProtectedData,
    } from '@iexec/dataprotector';

The `protectData` method returns the following fields, as a JSON object.

### name [â€‹](#name-1)

`string`

The optional name provided during invocation of the method. If no name is specified this value defaults to `Untitled`.

### address [â€‹](#address)

`Address`

The ETH address of the newly created `protectedData`.

### owner [â€‹](#owner)

`Address`

The ETH address of the creator and owner of this `protectedData`.

### schema [â€‹](#schema)

`DataSchema`

Metadata describing the fields provided in the `data` parameter. The data types are automatically detected and listed in the schema.

TIP

The following data types are automatically detected:

*   Scalars
    *   `bool`
    *   `f64` (JavaScript `number`)
    *   `i128` (JavaScript `bigint` up to 128 bits)
    *   `string`
*   Binary:
    *   `application/octet-stream`
    *   `application/pdf`
    *   `application/xml`
    *   `application/zip`
    *   `audio/midi`
    *   `audio/mpeg`
    *   `audio/x-wav`
    *   `image/bmp`
    *   `image/gif`
    *   `image/jpeg`
    *   `image/png`
    *   `image/webp`
    *   `video/mp4`
    *   `video/mpeg`
    *   `video/x-msvideo`

Any undetected binary data type is categorized as `application/octet-stream`

### creationTimestamp [â€‹](#creationtimestamp)

`number`

A unix-style timestamp indicating the creation time of this `protectedData`.

### transactionHash [â€‹](#transactionhash)

`string`

The ID of the transaction that happened on iExec's side chain. You may view details on the transaction using the [iExec explorer](https://explorer.iex.ec).

### zipFile [â€‹](#zipfile)

`Uint8Array`

Under the hood, your protected data will be **compressed as a zip file**. In this zip file, you'll find back all of your protected fields, each field being serialized with a tool called `Borsh`. You can find more details here: [deserializer](/references/iapp-generator/deserializer).

This is mainly returned for debug purpose.

### encryptionKey [â€‹](#encryptionkey)

`Uint8Array`

The encryption key generated by the client to encrypt the data. This key is for your own usage. You will not have to share it in the context of the iExec protocol or developer tools.

Under the hood, it is a symmetric AES-256 key.

TIP

The zip file generated is a `Uint8Array`, so if you want to handle the binary data or download it consider adding a zip extension to it.

### multiaddr [â€‹](#multiaddr)

`string` | `undefined`

The multiaddr field is the IPFS path of your encrypted data.

TIP

You can access your encrypted IPFS data with the link:

`https://ipfs-gateway.v8-bellecour.iex.ec/ipfs/abc123...`

`abc123...` is the second part of the returned string `/p2p/abc123...`
getProtectedData [â€‹](#getprotecteddata)
=======================================

This method allows the user to retrieve all protected data for a given owner, data schema, or both.

Results are ordered by `creationTimestamp` desc.

TIP

A data schema is the metadata describing the contents of the protected data object. The schema is returned as part of the [protectData](./protectData) method invocation.

Usage [â€‹](#usage)
-----------------

ts

    const listProtectedData = await dataProtectorCore.getProtectedData({
      owner: '0xa0c15e...',
      requiredSchema: {
        email: 'string',
      },
    });

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type GetProtectedDataParams } from '@iexec/dataprotector';

### protectedDataAddress Optional [â€‹](#protecteddataaddress)

**Type:** `AddressOrENS`

Returns the protected data associated with this address.  
Returns an empty array if the protected data is not found.

ts

    const oneProtectedData = await dataProtectorCore.getProtectedData({
      protectedDataAddress: '0x123abc...', 
    });

### requiredSchema Optional [â€‹](#requiredschema)

**Type:** `SearchableDataSchema`

Provides a list of protected data objects matching this schema.

ts

    const listProtectedData = await dataProtectorCore.getProtectedData({
      requiredSchema: { 
        email: 'string', 
      }, 
    });

It's also possible to provide a list of accepted types for one schema field:

ts

    const listProtectedData = await dataProtectorCore.getProtectedData({
      requiredSchema: { 
        picture: ['image/png', 'image/jpeg'], 
      }, 
    });

Available types are listed [here](/references/dataProtector/methods/protectData#schema).

### owner Optional [â€‹](#owner)

**Type:** `AddressOrENS`

Provides a list of protected data objects owned by the user with this ETH address.

ts

    const listProtectedData = await dataProtectorCore.getProtectedData({
      owner: '0xa0c15e...', 
    });

### createdAfterTimestamp Optional [â€‹](#createdaftertimestamp)

**Type:** `number`

Provides a list of protected data objects created after this timestamp value. The provided value should be in seconds.

ts

    const listProtectedData = await dataProtectorCore.getProtectedData({
      owner: '0xa0c15e...',
      createdAfterTimestamp: 1710257612, // March 12, 2024 15:33:32 GMT
    });

### page Optional [â€‹](#page)

**Type:** `number`  
**Default:** `0`

Specifies the results page to return. Pages are indexed starting at page 0. If using this field you may also specify a `pageSize` to control the size of the results.

ts

    const listProtectedData = await dataProtectorCore.getProtectedData({
      owner: '0xa0c15e...',
      createdAfterTimestamp: 1710257612, // March 12, 2024 15:33:32 GMT
      page: 1, 
    });

### pageSize Optional [â€‹](#pagesize)

**Type:** `number`  
**Default:** `1000`  
**Range:** `[10...1000]`

Specifies the number of records in each page of the result set. This is used in conjunction with the optional `page` parameter to constrain the size of the result.

ts

    const listProtectedData = await dataProtectorCore.getProtectedData({
      owner: '0xa0c15e...',
      createdAfterTimestamp: 1710257612, // March 12, 2024 15:33:32 GMT
      page: 1,
      pageSize: 100, 
    });

Return Value [â€‹](#return-value)
-------------------------------

ts

    import { type ProtectedData } from '@iexec/dataprotector';

See [`ProtectedData`](/references/dataProtector/types#protecteddata)
transferOwnership [â€‹](#transferownership)
=========================================

Allows transferring ownership of a `protectedData` entity to a new owner, identified by their ETH address. The return value provides a transaction hash and confirmation of the new owner of the `protectedData`. Only the current owner of the `protectedData` may invoke this method.

When transferring the `protectedData`, the grantedAccess created by the previous owner are revoked automatically.

Ownership of the `protectedData` can be renounced by transferring it to the burn address `0x000000000000000000000000000000000000dEaD`.

Usage [â€‹](#usage)
-----------------

ts

    const transferResponse = await dataProtectorCore.transferOwnership({
      protectedData: '0x123abc...',
      newOwner: '0xc5e9f4...',
    });

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type TransferParams } from '@iexec/dataprotector';

### protectedData Required \* [â€‹](#protecteddata)

**Type:** `AddressOrENS`

ETH address of the `protectedData` owned by you which is to be transferred to a new owner.

ts

    const transferResponse = await dataProtectorCore.transferOwnership({
      protectedData: '0x123abc...', 
      newOwner: '0xc5e9f4...',
    });

### newOwner Required \* [â€‹](#newowner)

**Type:** `AddressOrENS`

ETH address for the new owner for the `protectedData`.

ts

    const transferResponse = await dataProtectorCore.transferOwnership({
      protectedData: '0x123abc...',
      newOwner: '0xc5e9f4...', 
    });

Return Value [â€‹](#return-value)
-------------------------------

ts

    import { type TransferResponse } from '@iexec/dataprotector';

The result of this method is an array of objects identifying the new owner. The objects contain the three fields:

### address [â€‹](#address)

`Address`

The ETH address of the `protectedData` you transferred.

### to [â€‹](#to)

`AddressOrENS`

The ETH address of the new owner of the `protectedData`.

### txHash [â€‹](#txhash)

`string`

The ID of the transaction that happened on iExec's side chain. You may view details on the transaction using the [iExec explorer](https://explorer.iex.ec).

grantAccess [â€‹](#grantaccess)
=============================

Data encrypted through the Data Protector tool requires explicit authorization for runtime access. A newly created `protectedData` object has no inherent authorizations. This method grants permission to securely access the specified `protectedData` for processing using the `processProtectedData` method. Authorization to use the `protectedData` is given to a user in the context of an application (or a designated list of applications).

Usage [â€‹](#usage)
-----------------

ts

    const grantedAccess = await dataProtectorCore.grantAccess({
      protectedData: '0x123abc...',
      authorizedApp: '0x456def...',
      authorizedUser: '0x789cba...',
      pricePerAccess: 3,
      numberOfAccess: 10,
      onStatusUpdate: ({ title, isDone }) => {
        console.log(title, isDone);
      },
    });

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type GrantAccessParams } from '@iexec/dataprotector';

### protectedData Required \* [â€‹](#protecteddata)

**Type:** `AddressOrENS`

The ethereum address of the protected data supplied by the user (returned when you created it). **You must own this data** to grant access.

ts

    const grantedAccess = await dataProtectorCore.grantAccess({
      protectedData: '0x123abc...', 
      authorizedApp: '0x456def...',
      authorizedUser: '0x789cba...',
    });

### authorizedApp Required \* [â€‹](#authorizedapp)

**Type:** `AddressOrENS`

The address of the application you wish to authorize to process the `protectedData` within a secure execution environment. You may specify either a single application or an application whitelist. To specify a whitelist, you provide the ETH address of an [iExec Whitelist Smart Contract](https://github.com/iExecBlockchainComputing/whitelist-smart-contract/tree/main). This smart contract should aggregates multiple application versions. This allows you to introduce new versions of your application without needing to grant access for the `protectedData` each time you do so.

ts

    const grantedAccess = await dataProtectorCore.grantAccess({
      protectedData: '0x123abc...',
      authorizedApp: '0x456def...', 
      authorizedUser: '0x789cba...',
    });

TIP

You may authorize a specific app or a whitelist of apps to use the protected data.

The latest version of the iExec Web3Mail decentralized application is `web3mail.apps.iexec.eth`.

iExec also maintains a whitelist for current and past versions of Web3Mail iApp. Granting access to this whitelist allows use of an email `protectedData` with all versions of the Web3Mail application, ensuring you only have to grant this access once. The ETH address for this whitelist is **0x781482C39CcE25546583EaC4957Fb7Bf04C277D2**.

### authorizedUser Required \* [â€‹](#authorizeduser)

**Type:** `AddressOrENS`

The address of the user you wish to authorize to use the `protectedData`. Note that these users may not view or manipulate the data. This only grants permission for the user to submit the data to an iExec application.

ts

    const grantedAccess = await dataProtectorCore.grantAccess({
      protectedData: '0x123abc...',
      authorizedApp: '0x456def...',
      authorizedUser: '0x789cba...', 
    });

TIP

You may authorize all users to use the protected data by setting this to **0x0000000000000000000000000000000000000000**.

### pricePerAccess Optional [â€‹](#priceperaccess)

**Type:** `number`  
**Default:** `0`

Specifies the usage fee in nano RLC (nRLC) associated with each access of the data. It represents the cost incurred for each individual interaction with application.

By invoking the grantAccess method with a specific `pricePerAccess` you define the fee that the specified user (`authorizedUser` parameter) must pay for each access to the data when used with the specified application (`authorizedApp` parameter).

The fee is paid to the owner of the protected data.

ts

    const grantedAccess = await dataProtectorCore.grantAccess({
      protectedData: '0x123abc...',
      authorizedApp: '0x456def...',
      authorizedUser: '0x789cba...',
      pricePerAccess: 3, 
      numberOfAccess: 10,
    });

TIP

`pricePerAccess` is expressed in nano RLC (nRLC). nRLC is the smallest subdivision of the RLC token, 1 RLC equals to 10^9 nRLC.

When provided, `pricePerAccess` must be a non-negative integer value.

### numberOfAccess Optional [â€‹](#numberofaccess)

**Type:** `number`  
**Default:** `1`

Allows restricting the number of times the protected data may be processed and used.

It is not technically possible to set an unlimited number of accesses, but you can set `numberOfAccess` to `10000` for example.

INFO

If you attempt to process the protected data more times than specified in `numberOfAccess`, you will encounter a **"no dataset orders"** error.

To prevent this error, ensure the `numberOfAccess` is properly set when calling the `grantAccess` method.

ts

    const grantedAccess = await dataProtectorCore.grantAccess({
      protectedData: '0x123abc...',
      authorizedApp: '0x456def...',
      authorizedUser: '0x789cba...',
      pricePerAccess: 3,
      numberOfAccess: 10, 
    });

### allowBulk Optional [â€‹](#allowbulk)

**Type:** `boolean`

**Default:** `false`

When set to `true`, enables bulk processing for this access grant. This allows multiple protected data items to be processed together.

When `allowBulk: true` is set, the price per access is automatically set to `0` and the number of accesses is unlimited.

ts

    const grantedAccess = await dataProtectorCore.grantAccess({
      protectedData: '0x123abc...',
      authorizedApp: '0x456def...',
      authorizedUser: '0x789cba...',
      allowBulk: true, // Enable bulk processing
    });

### onStatusUpdate Optional [â€‹](#onstatusupdate)

**Type:** `OnStatusUpdateFn<GrantAccessStatuses>`

Callback function to be notified at intermediate steps.

ts

    const grantedAccess = await dataProtectorCore.grantAccess({
      protectedData: '0x123abc...',
      authorizedApp: '0x456def...',
      authorizedUser: '0x789cba...',
      onStatusUpdate: ({ title, isDone }) => { 
        console.log(title, isDone); 
      }, 
    });

You can expect this callback function to be called with the following titles:

ts

    'CREATE_DATASET_ORDER';
    'PUBLISH_DATASET_ORDER';

Once with `isDone: false`, and then with `isDone: true`

Return Value [â€‹](#return-value)
-------------------------------

ts

    import { type GrantedAccess } from '@iexec/dataprotector';

The result of this method confirms the new access grant. It consists of a JSON `grantedAccess` object.

[`GrantedAccess`](/references/dataProtector/types#grantedaccess)

getGrantedAccess [â€‹](#getgrantedaccess)
=======================================

This method provides a listing of all access grants given for the specified protected data object. Options for filtering include specifying an authorized user, an authorized app, or both.

Usage [â€‹](#usage)
-----------------

The request object is a JSON `GetGrantedAccessParams` object. Each address in the object is a string representation of an ethereum address or ENS name (Ethereum Name Service) reference.

ts

    const listGrantedAccess = await dataProtectorCore.getGrantedAccess({
      protectedData: '0x123abc...',
      authorizedApp: '0x456def...',
      authorizedUser: '0x789cba...',
      page: 1,
      pageSize: 100,
    });

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type GetGrantedAccessParams } from '@iexec/dataprotector';

### protectedData Optional [â€‹](#protecteddata)

**Type:** `AddressOrENS`

Address of the protected data object for which you are querying access authorization grants. It's a representation of ethereum address or ENS name (Ethereum Name Service). If no address is specified, it will return all granted access for any protected data.

**Usage example:**

ts

    const listGrantedAccess = await dataProtectorCore.getGrantedAccess({
      protectedData: '0x123abc...', 
    });

### authorizedApp Optional [â€‹](#authorizedapp)

**Type:** `AddressOrENS`

Optional filter to restrict the results to include only authorizations for the specified application. It's a representation of ethereum address or ENS name (Ethereum Name Service). If no address is specified, it will return all granted access for any application.

**Usage example:**

ts

    const listGrantedAccess = await dataProtectorCore.getGrantedAccess({
      authorizedApp: '0x456def...', 
    });

TIP

If you specified an application whitelist when using [`grantAccess`](/references/dataProtector/methods/grantAccess), you must specify that same whitelist address when using this filtering option. The `getGrantedAccess` method does not check against whitelist smart contracts when aggregating results. If you granted authorization to a whitelist but specify an application address for the `authorizedApp` parameter, you will not receive any results unless you _also_ explicitly granted access to that application address.

### authorizedUser Optional [â€‹](#authorizeduser)

**Type:** `AddressOrENS`

Optional filter to restrict the results to include only authorizations for the specified user. It's a string representation of ethereum address or ENS name (Ethereum Name Service). If no address is specified, it will return all granted access for any user.

**Usage example:**

ts

    const listGrantedAccess = await dataProtectorCore.getGrantedAccess({
      authorizedUser: '0x789cba...', 
    });

### isUserStrict Optional [â€‹](#isuserstrict)

**Type:** `boolean`  
**Default:** `false`

Optional filter to restrict the results to include only authorizations for the specified user. Authorizations made for `any` user are not returned.

ts

    
    const listGrantedAccess = await dataProtectorCore.getGrantedAccess({
      protectedData: '0x123abc...',
      authorizedApp: '0x456def...',
      authorizedUser: '0x789cba...',
      isUserStrict: true, 
    });

### page Optional [â€‹](#page)

**Type:** `number`  
**Default:** `0`

Specifies the page number of the result set to return. Pages are zero-based indexed, with the default value being `0`, indicating the first page. If used, you can also specify the `pageSize` parameter to control the number of records per page. By default, when no page number is specified, the system returns the first page (page 0) containing `20` elements.

**Usage example:**

ts

    const listGrantedAccess = await dataProtectorCore.getGrantedAccess({
      protectedData: '0x123abc...',
      page: 1, 
      pageSize: 100,
    });

### pageSize Optional [â€‹](#pagesize)

**Type:** `number`  
**Default:** `20`  
**Range:** `[10...1000]`

Specifies the number of records to include in each page of the result set. This is used in conjunction with the optional `page` parameter to limit the size of each page.

**Usage example:**

ts

    const listGrantedAccess = await dataProtectorCore.getGrantedAccess({
      protectedData: '0x123abc...',
      page: 1,
      pageSize: 100, 
    });

### bulkOnly Optional [â€‹](#bulkonly)

**Type:** `boolean`  
**Default:** `false`

Filter to retrieve only bulk access grants. When set to `true`, this method returns only granted accesses that were created with `allowBulk: true` when calling [`grantAccess`](/references/dataProtector/methods/grantAccess). This is useful when preparing bulk requests using [`prepareBulkRequest`](/references/dataProtector/methods/prepareBulkRequest).

**Usage example:**

ts

    const { grantedAccess } = await dataProtectorCore.getGrantedAccess({
      bulkOnly: true, 
    });

Return value [â€‹](#return-value)
-------------------------------

ts

    import { type GrantedAccessResponse } from '@iexec/dataprotector';

The return value for this method has two fields: a `count` parameter indicating the number of results, and an array of `GrantedAccess` objects containing all access data. When using the optional paging parameters, the `count` is limited by the selected `pageSize` parameter. You may use these result objects in conjunction with the [revokeOneAccess](./revokeOneAccess) method to revoke a previously granted authorization for access.

### Count [â€‹](#count)

**Type:** `number`

An integer value indicating the number of results returned by this method. This is of particular note when using paging as the number of records returned may be smaller than the page size.

### grantedAccess [â€‹](#grantedaccess)

git comm**Type:** `GrantedAccess`

See [`GrantedAccess`](/references/dataProtector/types#grantedaccess)

revokeOneAccess [â€‹](#revokeoneaccess)
=====================================

This method allows revoking a specific access authorization from a `protectedData` entity. The input parameter for this method is sourced from the [getGrantedAccess](./getGrantedAccess) method, which provides a list of all authorizations on single `protectedData` entity.

As this will generate a blockchain transaction, expect it to take a least 5sec (a block time).

Usage [â€‹](#usage)
-----------------

The `revokeOneAccess` method requires a `grantedAccess` object as an input parameter. This object is retrieved from the [`getGrantedAccess`](/references/dataProtector/methods/getGrantedAccess) method.

ts

    const revokeAccess = await dataProtectorCore.revokeOneAccess({
      apprestrict: '0xea...',
      dataset: '0xA0C...',
      datasetprice: '0',
      requesterrestrict: '0xecb..',
      salt: '0x0147...',
      sign: '0xc22c1...',
      tag: '0x0000000000000000000000000000000000000000000000000000000000000003',
      volume: '1',
      workerpoolrestrict: '0x000...',
      remainingAccess: 1,
    });

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type GrantedAccess } from '@iexec/dataprotector';

### grantedAccess Required \* [â€‹](#grantedaccess)

**Type:** `GrantedAccess`

This is the complete `granted access` object retrieved from an invocation of `getGrantedAccess`.

ts

    const revokeAccess = await dataProtectorCore.revokeOneAccess({
      apprestrict: '0xea...', 
      dataset: '0xA0C...', 
      datasetprice: '0', 
      requesterrestrict: '0xecb..', 
      salt: '0x0147...', 
      sign: '0xc22c1...', 
      tag: '0x0000000000000000000000000000000000000000000000000000000000000003', 
      volume: '1', 
      workerpoolrestrict: '0x000...', 
      remainingAccess: 1, 
    });

WARNING

The tag must always be set to `0x0000000000000000000000000000000000000000000000000000000000000003`. This specific value indicates that the order is for a confidential asset (a protected data).

Result Value [â€‹](#result-value)
-------------------------------

ts

    import { type RevokedAccess } from '@iexec/dataprotector';

[`RevokedAccess`](/references/dataProtector/types#revokedaccess)

revokeAllAccess [â€‹](#revokeallaccess)
=====================================

This method allows revoking authorizations granted to a `protectedData` entity. You may optionally specify application or user addresses for revocation. If you do not specify either of these optional values, this method will revoke all access for all users and applications.

You must be the owner of the protected data.

Under the hood, all granted access will be retrieved and be revoked one by one. If by any chance there were **more than 20 granted access** to be revoked, you would need to call this `revokeAllAccess()` method more than once for all granted access to be actually revoked. Use `getGrantedAccess()` to ensure it is all done.

Usage [â€‹](#usage)
-----------------

ts

    const revokeAllAccessResult = await dataProtectorCore.revokeAllAccess({
      protectedData: '0x123abc...',
      authorizedApp: '0x456def...',
      authorizedUser: '0x789cba...',
    });

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type RevokeAllAccessParams } from '@iexec/dataprotector';

### protectedData Required \* [â€‹](#protecteddata)

**Type:** `AddressOrENS`

The address of the `protectedData` subject to access revocation.

ts

    const revokeAllAccessResult = await dataProtectorCore.revokeAllAccess({
      protectedData: '0x123abc...', 
    });

### authorizedApp Optional [â€‹](#authorizedapp)

**Type:** `AddressOrENS`

The application address to be removed from the authorization list for the specified `protectedData`. If no address is specified, it will revoke all access from the protected data, regardless of the app.

ts

    const revokeAllAccessResult = await dataProtectorCore.revokeAllAccess({
      protectedData: '0x123abc...',
      authorizedApp: '0x456def...', 
      authorizedUser: '0x789cba...',
    });

### authorizedUser Optional [â€‹](#authorizeduser)

**Type:** `AddressOrENS`

The user address to be removed from the authorization list for the specified `protectedData`. If no address is specified, it will revoke all access from the protected data, regardless of the authorized user.

ts

    const revokeAllAccessResult = await dataProtectorCore.revokeAllAccess({
      protectedData: '0x123abc...',
      authorizedApp: '0x456def...',
      authorizedUser: '0x789cba...', 
    });

### onStatusUpdate Optional [â€‹](#onstatusupdate)

**Type:** `OnStatusUpdateFn<RevokeAllAccessStatuses>`

Callback function to be notified at intermediate steps.

ts

    const revokeAllAccessResult = await dataProtectorCore.revokeAllAccess({
      protectedData: '0x123abc...',
      authorizedApp: '0x456def...',
      authorizedUser: '0x789cba...',
      onStatusUpdate: ({ title, isDone }) => { 
        console.log(title, isDone); 
      }, 
    });

You can expect this callback function to be called with the following titles:

ts

    'RETRIEVE_ALL_GRANTED_ACCESS';
    'REVOKE_ONE_ACCESS';

Once with `isDone: false`, and then with `isDone: true`

Return Value [â€‹](#return-value)
-------------------------------

ts

    import { type RevokedAccess } from '@iexec/dataprotector';

[`RevokedAccess[]`](/references/dataProtector/types#revokedaccess)

processProtectedData [â€‹](#processprotecteddata)
===============================================

Allows processing a protected dataset through use of a specified iExec application.

IMPORTANT

You must ensure this application has authorization to use the `protectedData`. You may grant this permission using the [`grantAccess`](/references/dataProtector/methods/grantAccess) method.

Usage [â€‹](#usage)
-----------------

ts

    const processProtectedDataResponse =
      await dataProtectorCore.processProtectedData({
        protectedData: '0x123abc...',
        app: '0x456def...',
        args: 'arg1 arg2',
        inputFiles: ['https://example.com/file1', 'https://example.com/file2'],
        secrets: {
          1: 'secret1',
          2: 'secret2',
        },
      });

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type ProcessProtectedDataParams } from '@iexec/dataprotector';

### protectedData Required \* [â€‹](#protecteddata)

**Type:** `AddressOrENS`

The ETH address or Ethereum Name Service (ENS) reference for the protected data you wish the `app` to process.

ts

    const processProtectedDataResponse =
      await dataProtectorCore.processProtectedData({
        protectedData: '0x123abc...', 
        app: '0x456def...',
      });

### app Required \* [â€‹](#app)

**Type:** `AddressOrENS`

The ETH address or Ethereum Name Service (ENS) address for the iExec application to process the protected data.

ts

    const processProtectedDataResponse =
      await dataProtectorCore.processProtectedData({
        protectedData: '0x123abc...',
        app: '0x456def...', 
      });

### path Optional [â€‹](#path)

**Type:** `string`

Under the hood, a protected data is a zip file. With this `path` parameter, you can specify the file you're interested in. The zip file will be uncompressed for you, and only the desired file will be given as the `result`.

ts

    const processProtectedDataResponse =
      await dataProtectorCore.processProtectedData({
        protectedData: '0x123abc...',
        app: '0x456def...',
        path: 'my-content', 
      });

### userWhitelist Optional [â€‹](#userwhitelist)

**Type:** `Address`

If access to the protected data is granted to a group of users via a whitelist contract, you must use this `userWhitelist` parameter. The value should be the whitelist contract address that has access to the protected data.

ts

    const processProtectedDataResponse =
      await dataProtectorCore.processProtectedData({
        protectedData: '0x123abc...',
        app: '0x456def...',
        userWhitelist: '0x656def...', 
      });

### encryptResult Optional [â€‹](#encryptresult)

**Type:** `boolean`  
**Default:** `false`

When set to `true`, the computation result will be encrypted using RSA encryption. This ensures that only you can decrypt and access the result, providing an additional layer of privacy and security for sensitive computation outputs.

If `encryptResult` is `true` and no `pemPrivateKey` is provided, a new RSA key pair will be automatically generated. The generated private key will be returned in the response as `pemPrivateKey`, which you must securely store to decrypt the result later.

ts

    const processProtectedDataResponse =
      await dataProtectorCore.processProtectedData({
        protectedData: '0x123abc...',
        app: '0x456def...',
        encryptResult: true, 
      });

TIP

When `encryptResult` is enabled, the `onStatusUpdate` callback will be notified with the following additional status titles:

*   `'GENERATE_ENCRYPTION_KEY'` - When a new key pair is being generated
*   `'PUSH_ENCRYPTION_KEY'` - When the public key is being pushed to the secrets manager

### pemPrivateKey Optional [â€‹](#pemprivatekey)

**Type:** `string`

A PEM-formatted RSA private key used to decrypt the encrypted computation result. This parameter can only be used when `encryptResult` is set to `true`.

If you provide a `pemPrivateKey`, it will be used to decrypt the result. If you don't provide one but have `encryptResult: true`, a new key pair will be generated automatically, and the private key will be returned in the response for you to store securely.

ts

    const processProtectedDataResponse =
      await dataProtectorCore.processProtectedData({
        protectedData: '0x123abc...',
        app: '0x456def...',
        encryptResult: true, 
        pemPrivateKey:
          '-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----', 
      });

DANGER

If you provide a `pemPrivateKey`, you must also set `encryptResult: true`. The method will throw a validation error if `pemPrivateKey` is provided without `encryptResult` being enabled.

TIP

The `pemPrivateKey` (whether provided or auto-generated) will be included in the response object when `encryptResult` is `true`. Make sure to securely store this key if you need to decrypt the result later using the [getResultFromCompletedTask()](/references/dataProtector/methods/getResultFromCompletedTask) method.

### args Optional [â€‹](#args)

**Type:** `string`

Set of execution arguments for the application.

ts

    const processProtectedDataResponse =
      await dataProtectorCore.processProtectedData({
        protectedData: '0x123abc...',
        app: '0x456def...',
        args: 'arg1 arg2', 
      });

DANGER

Do not use this to provide any sensitive information to the application. All arguments passed this way are visible in plain text using the [iExec explorer](https://explorer.iex.ec/bellecour) .

### inputFiles Optional [â€‹](#inputfiles)

**Type:** `string[]`

A set of URLs representing the input files required for application execution.

ts

    const processProtectedDataResponse =
      await dataProtectorCore.processProtectedData({
        protectedData: '0x123abc...',
        app: '0x456def...',
        inputFiles: ['https://example.com/file1', 'https://example.com/file2'], 
      });

### secrets Optional [â€‹](#secrets)

**Type:** `Record<number, string>`

A set of requester secrets necessary for the application's execution. This is represented as a mapping of numerical identifiers to corresponding secrets stored in the secrets manager needed for the application's execution.

Secrets are accessible during the application's execution as environment variables. For more details, see [Access requester secrets](/guides/build-iapp/advanced/access-confidential-assets).

ts

    const processProtectedDataResponse = await dataProtectorCore.processProtectedData({
      protectedData: '0x123abc...',
      app: '0x456def...',
      secrets: { 
        1: 'secret1', 
        2: 'secret2', 
      }, 
    });

### workerpool Optional [â€‹](#workerpool)

**Type:** `AddressOrENS | 'any'`  
**Default:** `prod-v8-bellecour.main.pools.iexec.eth`

It's the confidential computer on which the iExec application will run.

TIP

iExec currently offers a workerpool located at the address `prod-v8-bellecour.main.pools.iexec.eth`. This is the default workerpool for running confidential computations on the iExec platform.

TDX

ðŸ§ª While protected data are processed in **TEE** by **intel SGX** technology by default, `@iexec/dataprotector` can be configured to create and process protected data in the experimental **intel TDX** environment.

TDX mode is enabled by setting connecting the **TDX SMS** and using the **TDX workerpool**.

Browser

ts

    import { IExecDataProtectorCore } from '@iexec/dataprotector';
    
    const web3Provider = window.ethereum;
    // Instantiate dataProtector connected to the TDX SMS
    const dataProtectorCore = new IExecDataProtectorCore(web3Provider, {
      iexecOptions: {
        smsURL: 'https://sms.labs.iex.ec', 
      },
    });
    
    const processProtectedDataResponse =
      await dataProtectorCore.processProtectedData({
        protectedData: '0x123abc...',
        app: '0x456def...',
        workerpool: 'tdx-labs.pools.iexec.eth', 
      });

âš ï¸ Keep in mind: TDX mode is experimental and can be subject to instabilities or discontinuity.

ts

    const processProtectedDataResponse =
      await dataProtectorCore.processProtectedData({
        protectedData: '0x123abc...',
        app: '0x456def...',
        workerpool: '0xa5de76...', 
      });

### dataMaxPrice Optional [â€‹](#datamaxprice)

**Type:** `number`  
**Default:** `0`

Allows specifying the maximum amount (in nRLC) you are willing to pay the protected data owner for using their data. The owner of the protected data receives this as a payment for sharing their data.

ts

    const processProtectedDataResponse =
      await dataProtectorCore.processProtectedData({
        protectedData: '0x123abc...',
        app: '0x456def...',
        dataMaxPrice: 42, 
      });

### appMaxPrice Optional [â€‹](#appmaxprice)

**Type:** `number`  
**Default:** `0`

Allows specifying the maximum amount (in nRLC) you are willing to pay the iApp provider for using the deployed application.

ts

    const processProtectedDataResponse =
      await dataProtectorCore.processProtectedData({
        protectedData: '0x123abc...',
        app: '0x456def...',
        appMaxPrice: 42, 
      });

### workerpoolMaxPrice Optional [â€‹](#workerpoolmaxprice)

**Type:** `number`  
**Default:** `0`

Allows specifying the maximum amount you want to pay the workerpool provider for using their infrastructure to run the iApp in nRLC.

ts

    const processProtectedDataResponse =
      await dataProtectorCore.processProtectedData({
        protectedData: '0x123abc...',
        app: '0x456def...',
        workerpoolMaxPrice: 42, 
      });

### onStatusUpdate Optional [â€‹](#onstatusupdate)

**Type:** `OnStatusUpdateFn<ProcessProtectedDataStatuses>`

Callback function to be notified at intermediate steps.

ts

    const processProtectedDataResponse = await dataProtectorCore.processProtectedData({
      protectedData: '0x123abc...',
      app: '0x456def...',
      onStatusUpdate: ({ title, isDone }) => { 
        console.log(title, isDone); 
      }, 
    });

You can expect this callback function to be called with the following titles:

ts

    'FETCH_ORDERS';
    'PUSH_REQUESTER_SECRET';
    'GENERATE_ENCRYPTION_KEY';
    'PUSH_ENCRYPTION_KEY';
    'REQUEST_TO_PROCESS_PROTECTED_DATA';
    'TASK_EXECUTION';
    'CONSUME_TASK';
    'CONSUME_RESULT_DOWNLOAD';
    'CONSUME_RESULT_DECRYPT';

Once with `isDone: false`, and then with `isDone: true`

INFO

The `'GENERATE_ENCRYPTION_KEY'` and `'PUSH_ENCRYPTION_KEY'` status titles are only triggered when `encryptResult` is set to `true`.

Return Value [â€‹](#return-value)
-------------------------------

ts

    import { type ProcessProtectedDataResponse } from '@iexec/dataprotector';

### txHash [â€‹](#txhash)

`string`

The ID of the transaction that happened on iExec's side chain. You may view details on the transaction using the [iExec explorer](https://explorer.iex.ec/bellecour) .

### dealId [â€‹](#dealid)

`string`

Identifies the specific deal associated with this transaction.

### taskId [â€‹](#taskid)

`string`

A unique identifier associated with a task currently running on the iExec protocol. You can monitor task execution using the [iExec explorer](https://explorer.iex.ec/bellecour) .

TIP

The [getResultFromCompletedTask()](/references/dataProtector/methods/getResultFromCompletedTask) function allows you to retrieve the result of a completed task using its `taskId`.

Additionally, you can specify a **file path** within the ZIP archive to extract a specific file when required.

### result [â€‹](#result)

`ArrayBuffer`

The result is a ZIP file containing at least one mandatory file:

*   **computed.json**: This file contains metadata about the computation performed by the application.
*   additional files may be included depending on the dapp used.

INFO

In the case of the **Content Creator Delivery DApp**, the ZIP file will also include a file named **content**, which corresponds to the protected data processed during the task.

### pemPrivateKey [â€‹](#pemprivatekey-1)

`string`

The PEM-formatted RSA private key used to decrypt the encrypted computation result. This property is only present in the response when `encryptResult` is set to `true`.

If you provided a `pemPrivateKey` in the parameters, the same key will be returned. If you didn't provide one but enabled `encryptResult`, a newly generated private key will be returned, which you must securely store to decrypt the result.

TIP

You can use this `pemPrivateKey` with the [getResultFromCompletedTask()](/references/dataProtector/methods/getResultFromCompletedTask) method to decrypt and retrieve the result of a completed task.

prepareBulkRequest [â€‹](#preparebulkrequest)
===========================================

This method prepares a bulk request by grouping multiple protected data items that can be processed together efficiently. The prepared bulk request can then be processed using the [`processBulkRequest`](/references/dataProtector/methods/processBulkRequest) method.

INFO

This method is part of a two-step bulk processing process:

1.  **Prepare the bulk request** using `prepareBulkRequest` to create a bulk request
2.  **Process the bulk request** using `processBulkRequest` to execute the bulk processing

Usage [â€‹](#usage)
-----------------

BrowserNodeJS

ts

    import { IExecDataProtectorCore } from '@iexec/dataprotector';
    
    const web3Provider = window.ethereum;
    const dataProtectorCore = new IExecDataProtectorCore(web3Provider);
    
    // Get granted accesses with bulk capability
    const { grantedAccess } = await dataProtectorCore.getGrantedAccess({
      bulkOnly: true,
    });
    
    // Prepare the bulk request
    const { bulkRequest } = await dataProtectorCore.prepareBulkRequest({
      bulkAccesses: grantedAccess,
      app: '0x456def...',
      maxProtectedDataPerTask: 100,
    });

ts

    import { IExecDataProtectorCore, getWeb3Provider } from '@iexec/dataprotector';
    
    const web3Provider = getWeb3Provider('PRIVATE_KEY');
    const dataProtectorCore = new IExecDataProtectorCore(web3Provider);
    
    // Get granted accesses with bulk capability
    const { grantedAccess } = await dataProtectorCore.getGrantedAccess({
      bulkOnly: true,
    });
    
    // Prepare the bulk request
    const { bulkRequest } = await dataProtectorCore.prepareBulkRequest({
      bulkAccesses: grantedAccess,
      app: '0x456def...',
      maxProtectedDataPerTask: 100,
    });

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type PrepareBulkRequestParams } from '@iexec/dataprotector';

### bulkAccesses Required \* [â€‹](#bulkaccesses)

**Type:** `GrantedAccess[]`

An array of `GrantedAccess` objects representing protected data items that have been granted access with bulk processing capability. Use `bulkOnly: true` option in [`getGrantedAccess`](/references/dataProtector/methods/getGrantedAccess) to obtain bulk accesses. Each `GrantedAccess` must have been created with `allowBulk: true` when calling [`grantAccess`](/references/dataProtector/methods/grantAccess).

ts

    const { bulkRequest } = await dataProtectorCore.prepareBulkRequest({
      bulkAccesses: grantedAccess, 
      app: '0x456def...',
    });

### app Required \* [â€‹](#app)

**Type:** `AddressOrENS`

The ETH address or Ethereum Name Service (ENS) address for the iExec application that will process the protected data items in the bulk request.

ts

    const { bulkRequest } = await dataProtectorCore.prepareBulkRequest({
      bulkAccesses: grantedAccess,
      app: '0x456def...', 
    });

### maxProtectedDataPerTask Optional [â€‹](#maxprotecteddatapertask)

**Type:** `number | undefined`

**Default:** `100`

Limits the number of protected data items processed per task. If you have more protected data items than this limit, multiple tasks will be created.

ts

    const { bulkRequest } = await dataProtectorCore.prepareBulkRequest({
      bulkAccesses: grantedAccess,
      app: '0x456def...',
      maxProtectedDataPerTask: 50, 
    });

### workerpool Optional [â€‹](#workerpool)

**Type:** `AddressOrENS | 'any'`  
**Default:** `prod-v8-bellecour.main.pools.iexec.eth`

It's the confidential computer on which the iExec application will run.

TIP

iExec currently offers a workerpool located at the address `prod-v8-bellecour.main.pools.iexec.eth`. This is the default workerpool for running confidential computations on the iExec platform.

You can specify this during preparation or when processing the bulk request.

ts

    const { bulkRequest } = await dataProtectorCore.prepareBulkRequest({
      bulkAccesses: grantedAccess,
      app: '0x456def...',
      workerpool: '0xa5de76...', 
    });

### workerpoolMaxPrice Optional [â€‹](#workerpoolmaxprice)

**Type:** `number | undefined`

**Default:** `0`

The maximum amount (in nRLC) you are willing to pay the workerpool provider for using their infrastructure to run the application. You can specify this during preparation or when processing the bulk request.

ts

    const { bulkRequest } = await dataProtectorCore.prepareBulkRequest({
      bulkAccesses: grantedAccess,
      app: '0x456def...',
      workerpoolMaxPrice: 0.1 * 1e9, 
    });

### appMaxPrice Optional [â€‹](#appmaxprice)

**Type:** `number | undefined`

**Default:** `0`

The maximum amount (in nRLC) you are willing to pay the application provider for using the application.

ts

    const { bulkRequest } = await dataProtectorCore.prepareBulkRequest({
      bulkAccesses: grantedAccess,
      app: '0x456def...',
      appMaxPrice: 0.1 * 1e9, 
    });

### args Optional [â€‹](#args)

**Type:** `string | undefined`

Set of execution arguments for the application that will be used for all tasks in the bulk request.

ts

    const { bulkRequest } = await dataProtectorCore.prepareBulkRequest({
      bulkAccesses: grantedAccess,
      app: '0x456def...',
      args: 'arg1 arg2', 
    });

DANGER

Do not use this to provide any sensitive information to the application. All arguments passed this way are visible in plain text using the [iExec explorer](https://explorer.iex.ec/bellecour) .

### inputFiles Optional [â€‹](#inputfiles)

**Type:** `string[] | undefined`

A set of URLs representing the input files required for application execution. These files will be used for all tasks in the bulk request.

ts

    const { bulkRequest } = await dataProtectorCore.prepareBulkRequest({
      bulkAccesses: grantedAccess,
      app: '0x456def...',
      inputFiles: ['https://example.com/file1', 'https://example.com/file2'], 
    });

### secrets Optional [â€‹](#secrets)

**Type:** `Record<number, string> | undefined`

A set of requester secrets necessary for the application's execution. This is represented as a mapping of numerical identifiers to corresponding secrets stored in the secrets manager needed for the application's execution.

Secrets are accessible during the application's execution as environment variables. For more details, see [Access requester secrets](/guides/build-iapp/advanced/access-confidential-assets).

ts

    const { bulkRequest } = await dataProtectorCore.prepareBulkRequest({
      bulkAccesses: grantedAccess,
      app: '0x456def...',
      secrets: {
        1: 'secret1', 
        2: 'secret2', 
      }, 
    });

### encryptResult Optional [â€‹](#encryptresult)

**Type:** `boolean | undefined`

**Default:** `false`

Enable result encryption for the processed data. If enabled, you'll need to provide the `pemPrivateKey` when processing the bulk request to decrypt the results.

ts

    const { bulkRequest, pemPrivateKey } =
      await dataProtectorCore.prepareBulkRequest({
        bulkAccesses: grantedAccess,
        app: '0x456def...',
        encryptResult: true, 
      });

### pemPrivateKey Optional [â€‹](#pemprivatekey)

**Type:** `string | undefined`

Private key in PEM format for result encryption/decryption. If not provided and `encryptResult` is `true`, a new key pair will be generated and returned in the response.

ts

    const { bulkRequest, pemPrivateKey } =
      await dataProtectorCore.prepareBulkRequest({
        bulkAccesses: grantedAccess,
        app: '0x456def...',
        encryptResult: true,
        pemPrivateKey:
          '-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----', 
      });

### onStatusUpdate Optional [â€‹](#onstatusupdate)

**Type:** `OnStatusUpdateFn<PrepareBulkRequestStatuses>`

Callback function to be notified at intermediate steps during bulk request preparation. You can expect this callback function to be called with the following titles:

*   `'PUSH_REQUESTER_SECRET'` - Pushing requester secrets to the SMS
*   `'GENERATE_ENCRYPTION_KEY'` - Generating encryption key pair (if `encryptResult: true`)
*   `'PUSH_ENCRYPTION_KEY'` - Pushing encryption public key to the SMS (if `encryptResult: true`)
*   `'PREPARE_PROTECTED_DATA_BULK'` - Preparing the protected data bulk
*   `'CREATE_BULK_REQUEST'` - Creating the bulk request order

Each status is called once with `isDone: false`, and then with `isDone: true`.

ts

    const { bulkRequest } = await dataProtectorCore.prepareBulkRequest({
      bulkAccesses: grantedAccess,
      app: '0x456def...',
      onStatusUpdate: ({ title, isDone }) => {
        // Handle status updates
      }, 
    });

Return Value [â€‹](#return-value)
-------------------------------

ts

    import { type PrepareBulkRequestResponse } from '@iexec/dataprotector';

### bulkRequest [â€‹](#bulkrequest)

**Type:** `BulkRequest`

The prepared bulk request object that contains all the necessary information to process multiple protected data items together. This object should be passed to `processBulkRequest` to execute the bulk processing.

### pemPrivateKey [â€‹](#pemprivatekey-1)

**Type:** `string | undefined`

The private key in PEM format for result decryption. This is only returned if `encryptResult` was set to `true` when preparing the bulk request. You'll need to provide this key when processing the bulk request if you want to decrypt the results.

ts

    // Get granted accesses with bulk capability
    const { grantedAccess } = await dataProtectorCore.getGrantedAccess({
      bulkOnly: true,
    });
    
    // Prepare the bulk request with encryption
    const { bulkRequest, pemPrivateKey } =
      await dataProtectorCore.prepareBulkRequest({
        bulkAccesses: grantedAccess,
        app: '0x456def...',
        encryptResult: true,
      });
    
    // Use the bulkRequest and pemPrivateKey to process the bulk request
    const { tasks } = await dataProtectorCore.processBulkRequest({
      bulkRequest: bulkRequest, 
      pemPrivateKey: pemPrivateKey, 
      waitForResult: true,
    });

Related Documentation [â€‹](#related-documentation)
-------------------------------------------------

*   [processBulkRequest Method](/references/dataProtector/methods/processBulkRequest) - Process a prepared bulk request
*   [grantAccess Method](/references/dataProtector/methods/grantAccess) - Grant access with bulk processing capability
*   [processProtectedData Method](/references/dataProtector/methods/processProtectedData) - Process a single protected data item

processBulkRequest [â€‹](#processbulkrequest)
===========================================

This method processes a bulk request that has been created using the [`prepareBulkRequest`](/references/dataProtector/methods/prepareBulkRequest) method. It executes the bulk processing of multiple protected data items efficiently, creating one or more tasks depending on the number of protected data items and the `maxProtectedDataPerTask` limit.

Prerequisites

Before using this method, make sure you have:

1.  **Recipients granted access with bulk processing**: When calling [`grantAccess`](/references/dataProtector/methods/grantAccess) on the Data Protector SDK, recipients must set `allowBulk: true`
    
2.  **Prepared the bulk request**: Use [`prepareBulkRequest`](/references/dataProtector/methods/prepareBulkRequest) to create the bulk request that will be passed to this method
    

Usage [â€‹](#usage)
-----------------

BrowserNodeJS

ts

    import { IExecDataProtectorCore } from '@iexec/dataprotector';
    
    const web3Provider = window.ethereum;
    const dataProtectorCore = new IExecDataProtectorCore(web3Provider);
    
    // Get granted accesses with bulk capability
    const { grantedAccess } = await dataProtectorCore.getGrantedAccess({
      bulkOnly: true,
    });
    
    // Prepare the bulk request
    const { bulkRequest } = await dataProtectorCore.prepareBulkRequest({
      bulkAccesses: grantedAccess,
      app: '0x456def...',
    });
    
    // Process the bulk request
    const { tasks } = await dataProtectorCore.processBulkRequest({
      bulkRequest: bulkRequest,
    });

ts

    import { IExecDataProtectorCore, getWeb3Provider } from '@iexec/dataprotector';
    
    const web3Provider = getWeb3Provider('PRIVATE_KEY');
    const dataProtectorCore = new IExecDataProtectorCore(web3Provider);
    
    // Get granted accesses with bulk capability
    const { grantedAccess } = await dataProtectorCore.getGrantedAccess({
      bulkOnly: true,
    });
    
    // Prepare the bulk request
    const { bulkRequest } = await dataProtectorCore.prepareBulkRequest({
      bulkAccesses: grantedAccess,
      app: '0x456def...',
    });
    
    // Process the bulk request
    const { tasks } = await dataProtectorCore.processBulkRequest({
      bulkRequest: bulkRequest,
    });

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type ProcessBulkRequestParams } from '@iexec/dataprotector';

### bulkRequest Required \* [â€‹](#bulkrequest)

**Type:** `BulkRequest`

The prepared bulk request object that was created using [`prepareBulkRequest`](/references/dataProtector/methods/prepareBulkRequest). This object contains all the necessary information to process multiple protected data items together.

ts

    const { tasks } = await dataProtectorCore.processBulkRequest({
      bulkRequest: bulkRequest, 
    });

### workerpool Optional [â€‹](#workerpool)

**Type:** `AddressOrENS | 'any'`  
**Default:** `prod-v8-bellecour.main.pools.iexec.eth`

It's the confidential computer on which the iExec application will run.

TIP

iExec currently offers a workerpool located at the address `prod-v8-bellecour.main.pools.iexec.eth`. This is the default workerpool for running confidential computations on the iExec platform.

ts

    const { tasks } = await dataProtectorCore.processBulkRequest({
      bulkRequest: bulkRequest,
      workerpool: '0xa5de76...', 
    });

### path Optional [â€‹](#path)

**Type:** `string | undefined`

Under the hood, a protected data is a zip file. With this `path` parameter, you can specify the file you're interested in. The zip file will be uncompressed for you, and only the desired file will be given as the `result`. This applies to all protected data items in the bulk request.

ts

    const { tasks } = await dataProtectorCore.processBulkRequest({
      bulkRequest: bulkRequest,
      path: 'my-content', 
    });

### pemPrivateKey Optional [â€‹](#pemprivatekey)

**Type:** `string | undefined`

Private key in PEM format for result decryption. Required if `bulkRequest` uses result encryption (when `encryptResult` was set to `true` in `prepareBulkRequest`) and `waitForResult` is `true`.

ts

    const { tasks } = await dataProtectorCore.processBulkRequest({
      bulkRequest: bulkRequest,
      pemPrivateKey: pemPrivateKey, 
      waitForResult: true,
    });

### waitForResult Optional [â€‹](#waitforresult)

**Type:** `boolean | undefined`

**Default:** `false`

Whether to wait for the result of the bulk request processing. If `true`, the method will wait for all tasks to complete and return results. If `false`, it will return immediately with task IDs.

ts

    const { tasks } = await dataProtectorCore.processBulkRequest({
      bulkRequest: bulkRequest,
      waitForResult: true, 
    });

### onStatusUpdate Optional [â€‹](#onstatusupdate)

**Type:** `OnStatusUpdateFn<ProcessBulkRequestStatuses>`

Callback function to be notified at intermediate steps during bulk processing. You can expect this callback function to be called with the following titles:

*   `'FETCH_ORDERS'` - Fetching app and workerpool orders
*   `'CREATE_BULK_TASKS'` - Creating bulk tasks from matched orders
*   `'WAIT_FOR_WORKERPOOL_AVAILABILITY'` - Waiting for workerpool availability (when no workerpool order is available)
*   `'REQUEST_TO_PROCESS_BULK_DATA'` - Requesting to process bulk data (matching orders)
*   `'PROCESS_BULK_SLICE'` - Processing a slice of the bulk request (only when `waitForResult: true`)
*   `'TASK_EXECUTION'` - Task execution in progress (only when `waitForResult: true`)
*   `'TASK_RESULT_DOWNLOAD'` - Downloading task result (only when `waitForResult: true`)
*   `'TASK_RESULT_DECRYPT'` - Decrypting task result (only when `waitForResult: true` and encryption is enabled)

Each status is called once with `isDone: false`, and then with `isDone: true`.

ts

    const { tasks } = await dataProtectorCore.processBulkRequest({
      bulkRequest: bulkRequest,
      onStatusUpdate: ({ title, isDone, payload }) => {
        // Handle status updates
      }, 
    });

Return Value [â€‹](#return-value)
-------------------------------

ts

    import { type ProcessBulkRequestResponse } from '@iexec/dataprotector';

### tasks [â€‹](#tasks)

**Type:** `Array<{ taskId: string; dealId: string; bulkIndex: number }>` (when `waitForResult: false`)

**Type:**`Array<{ taskId: string; dealId: string; bulkIndex: number; success: boolean; status: TaskStatus; result?: ArrayBuffer; error?: Error }>` (when `waitForResult: true`)

An array of task objects created by processing the bulk request. Each task represents a batch of protected data items being processed together.

**When `waitForResult: false` (default):**

*   **taskId**: A unique identifier for the task
*   **dealId**: Identifies the specific deal associated with this task
*   **bulkIndex**: The index of this task within the bulk request (useful when multiple tasks are created)

**When `waitForResult: true`:**

*   **taskId**: A unique identifier for the task
*   **dealId**: Identifies the specific deal associated with this task
*   **bulkIndex**: The index of this task within the bulk request
*   **success**: Whether the task completed successfully
*   **status**: The task status (`'COMPLETED' | 'FAILED' | 'TIMEOUT'`)
*   **result**: The task result as an ArrayBuffer (only present if successful)
*   **error**: Error object if the task failed (only present if failed)

ts

    const { tasks } = await dataProtectorCore.processBulkRequest({
      bulkRequest: bulkRequest,
    });

Related Documentation [â€‹](#related-documentation)
-------------------------------------------------

*   [prepareBulkRequest Method](/references/dataProtector/methods/prepareBulkRequest) - Prepare a bulk request for processing
*   [grantAccess Method](/references/dataProtector/methods/grantAccess) - Grant access with bulk processing capability
*   [processProtectedData Method](/references/dataProtector/methods/processProtectedData) - Process a single protected data item
*   [getResultFromCompletedTask Method](/references/dataProtector/methods/getResultFromCompletedTask) - Retrieve results from completed tasks

getResultFromCompletedTask [â€‹](#getresultfromcompletedtask)
===========================================================

Method to get the result of a completed task.

Usage [â€‹](#usage)
-----------------

ts

    const completedTaskResult = await dataProtectorCore.getResultFromCompletedTask({
      taskId: '0x7ac398...',
    });

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type GetResultFromCompletedTaskParams } from '@iexec/dataprotector';

### taskId Required \* [â€‹](#taskid)

**Type:** `Address`

Address of the task ID data you'd like to get the result from.

ts

    const completedTaskResult = await dataProtectorCore.getResultFromCompletedTask({
      taskId: '0x7ac398...', 
    });

### path Optional [â€‹](#path)

**Type:** `string`

Under the hood, a protected data is a zip file. With this `path` parameter, you can specify the file you're interested in. The zip file will be uncompressed for you, and only the desired file will be given as the `result`.

ts

    const completedTaskResult = await dataProtectorCore.getResultFromCompletedTask({
      taskId: '0x7ac398...',
      path: 'content', 
    });

### pemPrivateKey Optional [â€‹](#pemprivatekey)

**Type:** `string`

If you have previously saved or generated a RSA keypair, you can reuse it in further calls.

It needs to be the private key corresponding to the public key initially used to encrypt the protected data.

ts

    const completedTaskResult = await dataProtectorCore.getResultFromCompletedTask({
      taskId: '0x7ac398...',
      pemPrivateKey: '-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----', 
    });

### onStatusUpdate Optional [â€‹](#onstatusupdate)

**Type:** `OnStatusUpdateFn<ConsumeProtectedDataStatuses>`

Callback function to be notified at intermediate steps.

ts

    const completedTaskResult =
      await dataProtectorCore.getResultFromCompletedTask({
        taskId: '0x7ac398...',
        onStatusUpdate: ({ title, isDone }) => { 
          console.log(title, isDone); 
        }, 
      });

You can expect this callback function to be called with the following titles:

ts

    'CONSUME_RESULT_DOWNLOAD';
    'CONSUME_RESULT_DECRYPT';

Once with `isDone: false`, and then with `isDone: true`

Return Value [â€‹](#return-value)
-------------------------------

ts

    import { type GetResultFromCompletedTaskResponse } from '@iexec/dataprotector';

### result [â€‹](#result)

`ArrayBuffer`

The actual content of the protected file.

Types [â€‹](#types)
=================

Types in DataProtector.

GrantedAccess [â€‹](#grantedaccess)
---------------------------------

### dataset: `string` [â€‹](#dataset-string)

*   Address of the `protectedData` containing user data

### datasetprice: `string` [â€‹](#datasetprice-string)

*   Total number of authorized accesses for processing a Protected Data when the access was signed and published

### volume: `string` [â€‹](#volume-string)

*   Number of authorized uses of this `protectedData`; each use decrements this counter

### remainingAccess: `number` [â€‹](#remainingaccess-number)

*   Number of remaining authorized accesses for processing a protected data; each use decrements this counter

### tag: `string` [â€‹](#tag-string)

*   Defines whether a `protectedData` is usable in a TEE environment; `0x00` is TEE while `0x03` is non-TEE

### apprestrict: `string` [â€‹](#apprestrict-string)

*   Address of the authorized application; a value of 0x0 indicates any application may access this data

### requesterrestrict: `string` [â€‹](#requesterrestrict-string)

*   Address of the requester authorized to use this `protectedData` in workloads; a value of 0x0 indicates any requester may use this data

### workerpoolrestrict: `string` [â€‹](#workerpoolrestrict-string)

*   Address of the decentralized infrastructure (worker pool) authorized to execute the application; a value of 0x0 indicates any worker pool may access this data

### salt: `string` [â€‹](#salt-string)

*   Random value to make an order unique and reusable as nonce in a blockchain transaction

### sign: `string` [â€‹](#sign-string)

*   Order signature of all the `grantedAccess` fields

ProtectedData [â€‹](#protecteddata)
---------------------------------

### name: `string` [â€‹](#name-string)

*   Name specified when the protected data was created. This piece of information is public and visible on-chain.

### address: `Address` [â€‹](#address-address)

*   Ethereum address of the protected data.

### owner: `Address` [â€‹](#owner-address)

*   Ethereum address of the protected data owner.

### schema: `DataSchema` [â€‹](#schema-dataschema)

*   Data schema for the protected data as defined when the protected data was created (see [protectedData](/references/dataProtector/methods/protectData)). `schema` provides a structured representation of the protected data format and attributes. This field plays a crucial role in understanding and interpreting the underlying structure of the sensitive information.

### creationTimestamp: `number` [â€‹](#creationtimestamp-number)

*   Timestamp specifying when the protected data was created, expressed in milliseconds since the epoch. This timestamp provides precise information about the moment of creation and can be used for chronological ordering or time-based operations.

### multiaddr: `string` | `undefined` [â€‹](#multiaddr-string-undefined)

*   The multiaddr field is the IPFS path of your encrypted data.

RevokedAccess [â€‹](#revokedaccess)
---------------------------------

### access: [`GrantedAccess`](#-grantedaccess) [â€‹](#access-grantedaccess)

*   The granted access that was revoked.

### txHash: `string` [â€‹](#txhash-string)

*   The ID of the transaction that happened on iExec's side chain. You may view details on the transaction using the [iExec explorer](https://explorer.iex.ec).

_Hash example:_ `0xc9c2d58fc01fe54149b7daf49a0026d4ab1fdd3d10fb7c76350790fff03fe24d`

You can read more about the [iExec Explorer](/get-started/tooling-and-explorers/iexec-explorer).

SuccessWithTransactionHash [â€‹](#successwithtransactionhash)
-----------------------------------------------------------

### txHash: `string` [â€‹](#txhash-string-1)

*   The hash of the transaction that happened on iExec's side chain. You may view details on the transaction using the [iExec explorer](https://explorer.iex.ec).

_Hash example:_ `0xc9c2d58fc01fe54149b7daf49a0026d4ab1fdd3d10fb7c76350790fff03fe24d`

Advanced Configuration [â€‹](#advanced-configuration)
===================================================

The `IExecDataProtector` constructor accepts additional configuration parameters. As these parameters are very specific, they are not needed for a standard usage of `@iexec/dataprotector`.

Similarly, not all functionalities need to be instantiated at once in the SDK, as described in the [getting started](/references/dataProtector/getting-started#instantiate-sdk) section.

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type DataProtectorConfigOptions } from '@iexec/dataprotector';

### dataprotectorContractAddress [â€‹](#dataprotectorcontractaddress)

`AddressOrENS`

The Ethereum contract address or ENS (Ethereum Name Service) for dataProtector smart contract. If not provided, the default dataProtector contract address will be used.

ts

    const dataProtector = new IExecDataProtector(web3Provider, {
      dataprotectorContractAddress: '0x123abc...', 
    });

### subgraphUrl [â€‹](#subgraphurl)

`string`

The subgraph URL for querying data.

If not provided, the default data protector subgraph provided by iExec will be used.

ts

    const dataProtector = new IExecDataProtector(web3Provider, {
      subgraphUrl: 'subgraph-url', 
    });

### ipfsNode [â€‹](#ipfsnode)

`string`

The IPFS node URL for content uploads. Use this option if you want to use your own IPFS node to upload content.

If not provided, the default IPFS node provided by iExec will be used.

ts

    const dataProtector = new IExecDataProtector(web3Provider, {
      ipfsNode: 'ipfs-node-url', 
    });

### ipfsGateway [â€‹](#ipfsgateway)

`string`

The IPFS gateway URL used for content downloads. Mainly used for checking content uploaded on the IPFS network. Use this option if you want to use your own IPFS node for content downloads.

If not provided, the default IPFS gateway provided by iExec will be used.

ts

    const dataProtector = new IExecDataProtector(web3Provider, {
      ipfsGateway: 'ipfs-gateway-url', 
    });

### iexecOptions [â€‹](#iexecoptions)

Low level configuration options for `iexec` SDK, see [iexec SDK documentation IExecConfigOptions](https://github.com/iExecBlockchainComputing/iexec-sdk/blob/master/docs/interfaces/IExecConfigOptions.md) for more details.

ts

    const dataProtector = new IExecDataProtector(web3Provider, {
      iexecOptions: { smsURL: 'sms-url' }, 
    });

INFO

ðŸ§ª While protected data are processed in **TEE** by **intel SGX** technology by default, `@iexec/dataprotector` can be configured to create and process protected data in the experimental **intel TDX** environment.

TDX mode is enabled by setting connecting the TDX SMS and using the TDX workerpool.

Browser

ts

    import { IExecDataProtector } from '@iexec/dataprotector';
    
    const web3Provider = window.ethereum;
    // Instantiate dataProtector connected to the TDX SMS
    const dataProtector = new IExecDataProtector(web3Provider, {
      iexecOptions: {
        smsURL: 'https://sms.labs.iex.ec',
      },
    });

âš ï¸ Keep in mind: TDX mode is experimental and can be subject to instabilities or discontinuity.

Getting Started [â€‹](#getting-started)
=====================================

Prerequisites [â€‹](#prerequisites)
---------------------------------

Before using the iApp Generator, make sure you have:

ðŸ“¦ Node.js v20+ (for javascript iApps)

[Download â†’](https://nodejs.org/en/)

ðŸ Python 3.8+ (for Python iApps)

[Download â†’](https://www.python.org/downloads/)

ðŸ³ Docker installed

[Download â†’](https://docker.com/)

ðŸ³ DockerHub Account

[Sign Up â†’](https://hub.docker.com/)

ðŸ’° RLC Tokens

[Learn More â†’](/get-started/overview/rlc)

ðŸ” Verify Docker Compatibility

bash

    docker buildx inspect --bootstrap | grep -i platforms

If `linux/amd64` is not listed, **update your Docker installation.**

### Installation [â€‹](#installation)

npmyarnpnpmbun

sh

    npm install -g @iexec/iapp

sh

    yarn global add @iexec/iapp

sh

    pnpm add -g @iexec/iapp

sh

    bun add -g @iexec/iapp

Once installed, generate the auto-completion script and add it to your shell by following the instructions:

bash

    iapp completion

    Build your iApp [â€‹](#build-your-iapp)
=====================================

ðŸ“‹ Prerequisites

Before building your iApp, make sure you have the required tools installed. See the [Getting Started guide](/references/iapp-generator/getting-started) for detailed prerequisites and installation instructions.

Initialize your iApp [â€‹](#initialize-your-iapp)
-----------------------------------------------

The iApp (iExec App) Generator command-line tool simplifies the setup of your iApp by guiding you through a step-by-step initialization process. This ensures your iApp is correctly configured and compatible with iExec's confidential computing environment.

### Define your project [â€‹](#define-your-project)

Terminal

$ iapp init

Follow the prompts to specify:

*   **Project name** â€“ Creates a folder for your project files.
*   **Language** â€“ Choose between JavaScript, Python, etc.
*   **Project mode** â€“ Choose Basic (Hello-World setup) or Advanced mode.

### Configure [â€‹](#configure)

You'll set up:

*   **Arguments (Args)** â€“ Public parameters for your iApp.
*   **Input Files** â€“ Files dynamically downloaded during execution. These can come from **a specific URL**.
*   **Requester Secrets** â€“ Confidential authentication strings.
*   **Protected Data** â€“ Encrypted data accessible only inside the TEE.
*   **App Secret** â€“ Immutable secret provisioned by the iApp owner.

For more details and to learn how to use them in your application, refer here [Inputs](/guides/build-iapp/inputs).

Build your iApp [â€‹](#build-your-iapp-1)
---------------------------------------

After initialization, the following essential files and directories are generated:

*   `iapp.config.json`
*   `src/app.js` _(JavaScript)_ or `src/app.py` _(Python)_
*   `Dockerfile`
*   Directories:
    *   `input/`
    *   `output/`
    *   `cache/`

To modify your main application logic open:

sh

    src/app.js  # For JavaScript
    src/app.py  # For Python

INFO

ðŸ’¡ The `src/` directory contains the core logic of your iApp. Implement your algorithms and data processing here.

CLI Commands Reference [â€‹](#cli-commands-reference)
---------------------------------------------------

### `iapp init` [â€‹](#iapp-init)

**Purpose**: Initialize a new iApp project  
**Usage**: `iapp init`  
**What it does**: Creates project structure, configuration files, and basic templates through interactive prompts.

### `iapp test` [â€‹](#iapp-test)

**Purpose**: Test your iApp locally before deployment  
**Usage**: `iapp test [options]`  
**Options**:

*   `-v, --version` \[boolean\] â€“ Show version number
*   `--args <string>` â€“ Arguments accessible inside the iApp (use quotes to group)
*   `--protectedData <string>` â€“ Specify the protected data mock name (default or custom via `iapp mock`)
*   `--inputFile <string>` â€“ One or multiple input files (public URLs) available inside the iApp at `$IEXEC_INPUT_FILE_NAME_*`
*   `--requesterSecret <array>` â€“ Key-value requester secrets (`index=value`) available inside the iApp at `$IEXEC_REQUESTER_SECRET_*`

### `iapp deploy` [â€‹](#iapp-deploy)

**Purpose**: Deploy your iApp to the iExec network  
**Usage**: `iapp deploy [options]`  
**Options**:

*   `--chain <string>` â€“ Specify the blockchain network for deployment (e.g., `arbitrum-mainnet`, `arbitrum-sepolia-testnet`, `bellecour`)

### `iapp run <iAppAddress>` [â€‹](#iapp-run-iappaddress)

**Purpose**: Execute your deployed iApp on a worker node  
**Usage**: `iapp run <iAppAddress> [options]`  
**Positional arguments**:

*   `<iAppAddress>` â€“ Address of the deployed iApp to run

**Options**:

*   `--args <string>` â€“ Arguments accessible inside the iApp (use quotes to group)
*   `--protectedData <string>` â€“ Specify the protected data mock name (default or custom via `iapp mock`)
*   `--inputFile <string>` â€“ One or multiple input files (public URLs) available inside the iApp at `$IEXEC_INPUT_FILE_NAME_*`
*   `--requesterSecret <array>` â€“ Key-value requester secrets (`index=value`) available inside the iApp at `$IEXEC_REQUESTER_SECRET_*`
*   `--chain <string>` â€“ Specify the blockchain network to run the iApp on (e.g., `arbitrum-mainnet`, `arbitrum-sepolia-testnet`, `bellecour`)

### `iapp debug <taskId>` [â€‹](#iapp-debug-taskid)

**Purpose**: Retrieve detailed execution logs from worker nodes  
**Usage**: `iapp debug <taskId> [options]`  
**Positional arguments**:

*   `<taskId>` â€“ The ID of the task to debug

**Options**:

*   `--chain <string>` â€“ Specify the blockchain network of the task (e.g., `arbitrum-mainnet`, `arbitrum-sepolia-testnet`, `bellecour`)

### `iapp mock <inputType>` [â€‹](#iapp-mock-inputtype)

**Purpose**: Create a mocked input for testing  
**Usage**: `iapp mock <inputType> [options]`  
**Positional arguments**:

*   `<inputType>` â€“ Type of input to mock \[choices: "protectedData"\]

### `iapp wallet <action>` [â€‹](#iapp-wallet-action)

**Purpose**: Manage wallet-related operations  
**Usage**: `iapp wallet <action> [options]`  
**Positional arguments**:

*   `<action>` â€“ Import a new wallet or select one from the keystore \[choices: "import", "select"\]

Advanced Options [â€‹](#advanced-options)
---------------------------------------

### `EXPERIMENTAL_TDX_APP=true` [â€‹](#experimental-tdx-app-true)

**Purpose**: Enable experimental Intel TDX support  
**Usage**: Set as environment variable before running commands  
**Example**: `EXPERIMENTAL_TDX_APP=true iapp test`

**Available with**:

*   `iapp test`
*   `iapp deploy`
*   `iapp run <app-address>`

TDX

ðŸ§ª While **TEE** iApp are based on **intel SGX** technology by default, iApp has an experimental support for **intel TDX** applications.

TDX mode is enabled by setting the environment variable `EXPERIMENTAL_TDX_APP=true`.

âš ï¸ Keep in mind: TDX mode is experimental and can be subject to instabilities or discontinuity.

Next Steps [â€‹](#next-steps)
---------------------------

Your iApp is now running on iExec!

Once your application is **stable** and **functional**, you can learn how to [manage access to your iApp](/guides/build-iapp/manage-access)

Deserialize a ProtectedData [â€‹](#deserialize-a-protecteddata)
=============================================================

If you want to build your own iApp (iExec TEE Dapp), you may need to access protected data that your wallet and iApp are authorized to use. To achieve this, you must deserialize the content of the protected data with the expected data schema.

To simplify this process, you can use the lightweight utility package, `@iexec/dataprotector-deserializer`, in your iApp. This package streamlines the deserialization of protected data, making it easy for you to access and use the information securely.

Overview [â€‹](#overview)
-----------------------

This deserializer is built on the [Borsh technical specification](https://borsh.io/). iExec developed this JavaScript library to simplify deserialization in your iApp built with JavaScript.

WARNING

If you want to build your iApp in another language, you need to know how to deserialize a protected data.

Under the hood, protected data are **zip files** replicating the tree structure of the original data object. iExec's protocol stores each value in a dedicated file, the system stores binary values as is while it handles boolean, numbers, and strings serialized with Borsh.

To access a value from a protected data, your app will need to unzip the iExec dataset file at `$IEXEC_IN/$IEXEC_DATASET_FILENAME`. Then for `'bool'`, `'f64'`, `'i128'` or `'string'` types, use the Borsh deserialization specification to recover the original value. Borsh has [implementations in various languages](https://github.com/near/borsh#implementations), check your favorite one.

### Prerequisites [â€‹](#prerequisites)

Before getting started, ensure that you have the following installed on your system:

\- [**Node.js**](https://nodejs.org/en/) version 14 or higher

\- [**NPM**](https://docs.npmjs.com/) (Node.js package manager)

### Installation [â€‹](#installation)

npmyarnpnpmbun

sh

    npm install @iexec/dataprotector-deserializer

sh

    yarn add @iexec/dataprotector-deserializer

sh

    pnpm add @iexec/dataprotector-deserializer

sh

    bun add @iexec/dataprotector-deserializer

### Instantiate SDK [â€‹](#instantiate-sdk)

NodeJS

ts

    import { IExecDataProtectorDeserializer } from '@iexec/dataprotector-deserializer';
    
    const deserializer = new IExecDataProtectorDeserializer();

    getValue [â€‹](#getvalue)
=======================

Method to deserialize a value given a provided type.

Usage [â€‹](#usage)
-----------------

NodeJS

ts

    const value1 = await deserializer.getValue('path.to.value1', 'bool');
    const value2 = await deserializer.getValue('path.to.value2', 'string');

Parameters [â€‹](#parameters)
---------------------------

ts

    import { IExecDataProtectorDeserializer } from '@iexec/dataprotector-deserializer';

### path [â€‹](#path)

`string`

The path of the value inside the protected data that you want to deserialize.

NodeJS

ts

    const value1 = await deserializer.getValue(
      'path.to.value1', 
      'bool'
    );

### type [â€‹](#type)

`string`

Type of the desired data. The supported types are:

*   `bool` | `f64` | `i128` | `bigint` | `string` | `Uint8Array` | `boolean` (legacy schema) | `number` (legacy schema)

NodeJS

ts

    const value1 = await deserializer.getValue(
      'path.to.value1',
      'bool'
    );

Return Value [â€‹](#return-value)
-------------------------------

The recovered original value.

Getting Started [â€‹](#getting-started)
=====================================

[![GitHub package.json version (branch)](https://img.shields.io/github/package-json/v/iExecBlockchainComputing/web3mail-sdk?color=green)](https://github.com/iExecBlockchainComputing/web3mail-sdk)

Overview [â€‹](#overview)
-----------------------

### Prerequisites [â€‹](#prerequisites)

Before getting started, ensure that you have the following installed on your system:

\- [**Node.js**](https://nodejs.org/en/) version 18 or higher

\- [**NPM**](https://docs.npmjs.com/) (Node.js package manager)

### Installation [â€‹](#installation)

npmyarnpnpmbun

sh

    npm install @iexec/web3mail

sh

    yarn add @iexec/web3mail

sh

    pnpm add @iexec/web3mail

sh

    bun add @iexec/web3mail

**This package is an ESM package. Your project needs to use ESM too.** Â [**Read more**](https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c)

If you use it with **Webpack**, some polyfills will be needed. You can find a working project [here](https://github.com/iExecBlockchainComputing/web3mail-sdk/tree/main/demo/browser-webpack).

### Instantiate with a Web3 Provider [â€‹](#instantiate-with-a-web3-provider)

BrowserNodeJS

ts

    import { IExecWeb3mail } from '@iexec/web3mail';
    
    const web3Provider = window.ethereum;
    // instantiate
    const web3mail = new IExecWeb3mail(web3Provider);

ts

    import { IExecWeb3mail, getWeb3Provider } from '@iexec/web3mail';
    
    // get web3 provider from a private key
    const web3Provider = getWeb3Provider('YOUR_PRIVATE_KEY');
    // instantiate
    const web3mail = new IExecWeb3mail(web3Provider);

### Instantiate Without a Web3 Provider [â€‹](#instantiate-without-a-web3-provider)

For projects that only require read functions, you can instantiate the SDK without a Web3 provider.

BrowserNodeJS

ts

    import { IExecWeb3mail } from '@iexec/web3mail';
    
    // instantiate
    const web3mail = new IExecWeb3mail();

ts

    import { IExecWeb3mail, getWeb3Provider } from '@iexec/web3mail';
    
    // instantiate
    const web3mail = new IExecWeb3mail();

Sandbox [â€‹](#sandbox)
---------------------

[âš¡ Â Code Sandbox](https://codesandbox.io/p/github/iExecBlockchainComputing/web3mail-sandbox/main)

Corresponding GitHub repository:

[ðŸ”Ž Â GitHub repository sandbox](https://github.com/iExecBlockchainComputing/web3Mail-sandbox)

fetchMyContacts [â€‹](#fetchmycontacts)
=====================================

This method provides a list of `contact` objects identifying all users who previously granted authorization to send them email messages. Each contact contains the contact's ETH address as well as the ETH address for the `protectedData` containing their email address.

Usage [â€‹](#usage)
-----------------

ts

    const contactsList = await web3mail.fetchMyContacts();

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type FetchMyContactsParams } from '@iexec/web3mail';

### isUserStrict Optional [â€‹](#isuserstrict)

**Type:** `boolean`

This parameter enables fetching contacts who granted access exclusively to the user and no one else.

TIP

When you grant access to someone, you can choose to grant access to a specific user (a wallet) or to any user (`0x0000000000000000000000000000000000000000`).

ts

    const contactsList = await web3mail.fetchMyContacts({
      isUserStrict: true, 
    });

### bulkOnly Optional [â€‹](#bulkonly)

**Type:** `boolean`

**Default:** `false`

When set to `true`, this parameter filters contacts to only return those who have granted access with bulk processing capability. These contacts can be used with [`prepareEmailCampaign`](/references/web3mail/methods/prepareEmailCampaign) and [`sendEmailCampaign`](/references/web3mail/methods/sendEmailCampaign) for bulk campaigns.

WARNING

To enable bulk processing, recipients must grant access with `allowBulk: true` when calling [`grantAccess`](/references/dataProtector/methods/grantAccess) on the Data Protector SDK.

ts

    const bulkContacts = await web3mail.fetchMyContacts({
      bulkOnly: true, 
    });

Return Value [â€‹](#return-value)
-------------------------------

The result object contains a list of `contact` objects. Each `contact` represents one user who previously granted you authorization to send them messages.

ts

    import { type Contact } from '@iexec/web3mail';

[`Contact[]`](/references/dataProtector/types#contact)

fetchUserContacts [â€‹](#fetchusercontacts)
=========================================

This method provides a list of `contact` objects identifying all entities who previously granted authorization to a specified entity to send them email messages. Each contact contains the contact's ETH address as well as the ETH address for the `protectedData` containing their email address.

Usage [â€‹](#usage)
-----------------

ts

    const contactsList = await web3mail.fetchUserContacts({
      userAddress: '0x789cba...',
    });

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type FetchUserContactsParams } from '@iexec/web3mail';

### userAddress Required \* [â€‹](#useraddress)

**Type:** `Address`

The user for which you wish to obtain the list of contacts.

ts

    const contactsList = await web3mail.fetchUserContacts({
      userAddress: '0x789cba...', 
    });

### isUserStrict Optional [â€‹](#isuserstrict)

**Type:** `boolean`

This parameter enables fetching contacts who granted access exclusively to the user and no one else.

TIP

When someone grants access, you can choose to grant access to a specific user (a wallet) or to any user (`0x0000000000000000000000000000000000000000`).

ts

    const contactsList = await web3mail.fetchUserContacts({
      userAddress: '0x789cba...',
      isUserStrict: true, 
    });

### bulkOnly Optional [â€‹](#bulkonly)

**Type:** `boolean`

**Default:** `false`

When set to `true`, this parameter filters contacts to only return those who have granted access with bulk processing capability. These contacts can be used with [`prepareEmailCampaign`](/references/web3mail/methods/prepareEmailCampaign) and [`sendEmailCampaign`](/references/web3mail/methods/sendEmailCampaign) for bulk campaigns.

WARNING

To enable bulk processing, recipients must grant access with `allowBulk: true` when calling [`grantAccess`](/references/dataProtector/methods/grantAccess) on the Data Protector SDK.

ts

    // Fetch contacts with bulk access for a specific user
    const bulkContacts = await web3mail.fetchUserContacts({
      userAddress: '0x789cba...',
      bulkOnly: true, 
    });

Return Value [â€‹](#return-value)
-------------------------------

The result object contains a list of `contact` objects. Each `contact` represents one user who previously granted authorization for the user identified with `userAddress` to send them messages.

ts

    import { type Contact } from '@iexec/web3mail';

[`Contract[]`](/references/dataProtector/types#contact)

sendEmail [â€‹](#sendemail)
=========================

This method allows an authorized entity to send an email message to a user without needing to know their email address.

The recipient email address in a `protectedData` entity. The user receiving the email must explicitly authorize you to send them email communications and permission must be granted for the `Web3Mail` tool to use the `protectedData` entity containing their email address. This is best done by granting authorization to the Web3Mail app whitelist `0x781482C39CcE25546583EaC4957Fb7Bf04C277D2` as `authorizedApp`. Refer to the [Data Protector `grantAccess`](/references/dataProtector/methods/grantAccess) documentation for more details.

INFO

For sending bulk campaigns to multiple recipients, use [`prepareEmailCampaign`](/references/web3mail/methods/prepareEmailCampaign) and [`sendEmailCampaign`](/references/web3mail/methods/sendEmailCampaign).

TIP

For executing the `sendEmail` method with RLC, refer to the dedicated section in the documentation under "[How to Pay for Executions](/guides/use-iapp/how-to-pay-executions)".

Usage [â€‹](#usage)
-----------------

ts

    const sendEmail = await web3mail.sendEmail({
      protectedData: '0x123abc...',
      emailSubject: 'My email subject',
      emailContent: 'My email content',
    });

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type SendEmailParams } from '@iexec/web3mail';

### protectedData Required \* [â€‹](#protecteddata)

**Type:** `Address`

The address of the `protectedData` holding the contact's email address.

ts

    const sendEmail = await web3mail.sendEmail({
      protectedData: '0x123abc...', 
      emailSubject: 'My email subject',
      emailContent: 'My email content',
    });

### emailSubject Required \* [â€‹](#emailsubject)

**Type:** `string`  
**Max**: 78 characters

The subject line for the email you are sending. This field is limited to 78 characters. Any characters beyond that limited are truncated.

ts

    const sendEmail = await web3mail.sendEmail({
      protectedData: '0x123abc...',
      emailSubject: 'My email subject', 
      emailContent: 'My email content',
    });

### emailContent Required \* [â€‹](#emailcontent)

**Type:** `string`

optionally HTML encoded

_maximum size_: 512 kb

The email content that needs to be sent. The content is limited to 512 kb in size. Email content will be encrypted and stored in IPFS.

ts

    const sendEmail = await web3mail.sendEmail({
      protectedData: '0x123abc...',
      emailSubject: 'My email subject',
      emailContent: 'My email content', 
    });

### contentType Optional [â€‹](#contenttype)

**Type:** `text/plain` or `text/html`  
**Default:** `text/plain`

This is used by the mail client to properly render the delivered text. Set this to `text/html` to enable rich HTML content in your email.

ts

    const sendEmail = await web3mail.sendEmail({
      protectedData: '0x123abc...',
      emailSubject: 'My email subject',
      emailContent: '<h1>Hello world!</h1>',
      contentType: 'text/html', 
    });

### senderName Optional [â€‹](#sendername)

**Type:** `string`  
**Default:** `Web3Mail`  
**Min:** 3 characters  
**Max:** 20 characters

Allows specifying a sender name for the email. This is used by the mail client in rendering the email to the user. The Web3Mail tool appends `via Web3Mail` to the supplied name. Setting this to `Tom`, for example, will result in a sender name of, `Tom via Web3Mail`, in the delivered email. If no name is specified, the Web3Mail tool sets this to a value of `Web3Mail`.

ts

    const sendEmail = await web3mail.sendEmail({
      protectedData: '0x123abc...',
      emailSubject: 'My email subject',
      emailContent: 'My email content',
      senderName: 'Awesome project team', 
    });

### label Optional [â€‹](#label)

**Type:** `string`

Allows adding a custom public label. The Web3Mail tool writes this onchain as `iexec_args` in the deal params.

ts

    const sendEmail = await web3mail.sendEmail({
      protectedData: '0x123abc...',
      emailSubject: 'My email subject',
      emailContent: 'My email content',
      label: 'some-custom-id', 
    });

### workerpoolAddressOrEns Optional [â€‹](#workerpooladdressorens)

**Type:** `workerpoolAddressOrEns`  
**Default:** `prod-v8-bellecour.main.pools.iexec.eth` (iExec's workerpool)

Allows specifying the workerpool that will run the Web3Mail application.

ts

    const sendEmail = await web3mail.sendEmail({
      protectedData: '0x123abc...',
      emailSubject: 'My email subject',
      emailContent: 'My email content',
      workerpoolAddressOrEns: '0xa5de76...', 
    });

### dataMaxPrice Optional [â€‹](#datamaxprice)

**Type:** `number`  
**Default:** `0`

Allows specifying the maximum amount (in nRLC) you are willing to pay the email address owner for using their data. The owner of the protected email address receives this as a payment for sharing their data.

ts

    const sendEmail = await web3mail.sendEmail({
      protectedData: '0x123abc...',
      emailSubject: 'My email subject',
      emailContent: 'My email content',
      dataMaxPrice: 42, 
    });

### appMaxPrice Optional [â€‹](#appmaxprice)

**Type:** `number`  
**Default:** `0`

Allows specifying the maximum amount (in nRLC) you are willing to pay the Web3Mail app provider (iExec) for using the Web3Mail application.

ts

    const sendEmail = await web3mail.sendEmail({
      protectedData: '0x123abc...',
      emailSubject: 'My email subject',
      emailContent: 'My email content',
      appMaxPrice: 42, 
    });

### workerpoolMaxPrice Optional [â€‹](#workerpoolmaxprice)

**Type:** `number`  
**Default:** `0`

Allows specifying the maximum amount you want to pay the workerpool provider for using their infrastructure to run the web3mail app in nRLC.

ts

    const sendEmail = await web3mail.sendEmail({
      protectedData: '0x123abc...',
      emailSubject: 'My email subject',
      emailContent: 'My email content',
      workerpoolMaxPrice: 42, 
    });

Return Value [â€‹](#return-value)
-------------------------------

ts

    import { type SendEmailResponse } from '@iexec/web3mail';

### taskId [â€‹](#taskid)

**Type:** `Addess`

This uniquely identifies the email task on the iExec side chain. You can view the status of the `sendEmail` method by monitoring the task on the [iExec explorer](https://explorer.iex.ec/bellecour) .

Error Handling [â€‹](#error-handling)
-----------------------------------

### Validation Errors [â€‹](#validation-errors)

The system uses [yup](https://github.com/jquense/yup) to validate input parameters.

In case one is not valid, you'll get **a yup ValidationError**.

Example to check received Validation errors:

ts

    import { ValidationError } from '@iexec/web3mail';
    
    try {
      await web3mail.sendEmail({
        protectedData,
        senderName: 'ab', // Bad input
        emailSubject,
        emailContent,
      });
    } catch (err) {
      console.error(err.message); // "senderName must be at least 3 characters"
    
      // Or list all validation errors:
      if (err instanceof ValidationError) {
        console.error('Validation errors:', (err as ValidationError).errors);
      }
    }

### Email Schema Error [â€‹](#email-schema-error)

To be able to send an email to a protected data, it needs to contain, well, an email address.

If not, you'll get a `WorkflowError` in the form of:

json5

    {
      message: 'Failed to sendEmail',
      errorCause: Error('This protected data does not contain "email:string" in its schema.')
    }

### iExec Protocol Errors [â€‹](#iexec-protocol-errors)

In case the iExec stack is to blame, the system will make it clear and you'll get a specific `WorkflowError`:

json5

    {
      message: "A service in the iExec protocol appears to be unavailable. You can retry later or contact iExec's technical support for help.",
      errorCause: <Original error>,
      isProtocolError: true
    }

### Workflow Errors [â€‹](#workflow-errors)

For any other errors, you'll get a `WorkflowError` error in the form of:

json5

    {
      message: 'Failed to sendEmail',
      errorCause: <Original error>
    }

    prepareEmailCampaign [â€‹](#prepareemailcampaign)
===============================================

This method prepares a bulk email campaign by creating a bulk request that groups multiple protected data items. The prepared campaign request can then be sent using the [`sendEmailCampaign`](/references/web3mail/methods/sendEmailCampaign) method.

INFO

This method is part of a two-step bulk campaign process:

1.  **Prepare the campaign** using `prepareEmailCampaign` to create a bulk request
2.  **Send the campaign** using `sendEmailCampaign` to process the bulk request

Usage [â€‹](#usage)
-----------------

BrowserNodeJS

ts

    import { IExecWeb3mail } from '@iexec/web3mail';
    
    const web3Provider = window.ethereum;
    const web3mail = new IExecWeb3mail(web3Provider);
    
    // Fetch contacts with bulk access
    const contacts = await web3mail.fetchMyContacts({ bulkOnly: true });
    const grantedAccessArray = contacts.map((contact) => contact.grantedAccess);
    
    // Prepare the campaign
    const emailCampaign = await web3mail.prepareEmailCampaign({
      grantedAccesses: grantedAccessArray,
      emailSubject: 'My email subject',
      emailContent: 'My email content',
      contentType: 'text/plain',
    });

ts

    import { IExecWeb3mail, getWeb3Provider } from '@iexec/web3mail';
    
    const web3Provider = getWeb3Provider('PRIVATE_KEY');
    const web3mail = new IExecWeb3mail(web3Provider);
    
    // Fetch contacts with bulk access
    const contacts = await web3mail.fetchMyContacts({ bulkOnly: true });
    const grantedAccessArray = contacts.map((contact) => contact.grantedAccess);
    
    // Prepare the campaign
    const emailCampaign = await web3mail.prepareEmailCampaign({
      grantedAccesses: grantedAccessArray,
      emailSubject: 'My email subject',
      emailContent: 'My email content',
      contentType: 'text/plain',
    });

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type PrepareEmailCampaignParams } from '@iexec/web3mail';

### grantedAccesses Required \* [â€‹](#grantedaccesses)

**Type:** `GrantedAccess[]`

An array of `GrantedAccess` objects representing contacts who have granted you access to their protected data with bulk processing capability.

ts

    const emailCampaign = await web3mail.prepareEmailCampaign({
      grantedAccesses: grantedAccessArray, 
      emailSubject: 'My subject',
      emailContent: 'My content',
    });

### emailSubject Required \* [â€‹](#emailsubject)

**Type:** `string`

The email subject that will be sent to all recipients.

ts

    const emailCampaign = await web3mail.prepareEmailCampaign({
      grantedAccesses: grantedAccessArray,
      emailSubject: 'My email subject', 
      emailContent: 'My email content',
    });

### emailContent Required \* [â€‹](#emailcontent)

**Type:** `string`

**Maximum size:** `512 kb`

The email content that will be sent to all recipients. The content is encrypted and stored in IPFS.

ts

    const emailCampaign = await web3mail.prepareEmailCampaign({
      grantedAccesses: grantedAccessArray,
      emailSubject: 'My email subject',
      emailContent: 'My email content', 
    });

### contentType Optional [â€‹](#contenttype)

**Type:** `string | undefined`

**Default:** `'text/plain'`

The MIME type of the email content (e.g., `'text/plain'`, `'text/html'`).

ts

    const emailCampaign = await web3mail.prepareEmailCampaign({
      grantedAccesses: grantedAccessArray,
      emailSubject: 'My email subject',
      emailContent: 'My email content',
      contentType: 'text/html', 
    });

### maxProtectedDataPerTask Optional [â€‹](#maxprotecteddatapertask)

**Type:** `number | undefined`

**Default:** `100`

Limits the number of protected data items processed per task.

ts

    const emailCampaign = await web3mail.prepareEmailCampaign({
      grantedAccesses: grantedAccessArray,
      emailSubject: 'My email subject',
      emailContent: 'My email content',
      maxProtectedDataPerTask: 10, 
    });

### workerpoolAddressOrEns Optional [â€‹](#workerpooladdressorens)

**Type:** `AddressOrENS | undefined`

**Default:** Default workerpool from chain configuration

The workerpool address or ENS name that will execute the bulk campaign tasks. You can specify this during preparation or when sending the campaign.

ts

    const emailCampaign = await web3mail.prepareEmailCampaign({
      grantedAccesses: grantedAccessArray,
      emailSubject: 'My email subject',
      emailContent: 'My email content',
      workerpoolAddressOrEns: '0xa5de76...', 
    });

### workerpoolMaxPrice Optional [â€‹](#workerpoolmaxprice)

**Type:** `number | undefined`

**Default:** `0`

The maximum amount (in nRLC) you are willing to pay the workerpool provider for using their infrastructure to run the Web3Mail app. You can specify this during preparation or when sending the campaign.

ts

    const emailCampaign = await web3mail.prepareEmailCampaign({
      grantedAccesses: grantedAccessArray,
      emailSubject: 'My email subject',
      emailContent: 'My email content',
      workerpoolMaxPrice: 0.1 * 1e9, 
    });

### label Optional [â€‹](#label)

**Type:** `string | undefined`

An optional label to identify or categorize the campaign.

ts

    const emailCampaign = await web3mail.prepareEmailCampaign({
      grantedAccesses: grantedAccessArray,
      emailSubject: 'My email subject',
      emailContent: 'My email content',
      label: 'Newsletter Campaign', 
    });

### dataMaxPrice Optional [â€‹](#datamaxprice)

**Type:** `number | undefined`

**Default:** `0`

The maximum amount (in nRLC) you are willing to pay for accessing the protected data.

ts

    const emailCampaign = await web3mail.prepareEmailCampaign({
      grantedAccesses: grantedAccessArray,
      emailSubject: 'My email subject',
      emailContent: 'My email content',
      dataMaxPrice: 0.1 * 1e9, 
    });

### appMaxPrice Optional [â€‹](#appmaxprice)

**Type:** `number | undefined`

**Default:** `0`

The maximum amount (in nRLC) you are willing to pay the Web3Mail app provider for using the Web3Mail application.

ts

    const emailCampaign = await web3mail.prepareEmailCampaign({
      grantedAccesses: grantedAccessArray,
      emailSubject: 'My email subject',
      emailContent: 'My email content',
      appMaxPrice: 0.1 * 1e9, 
    });

Return Value [â€‹](#return-value)
-------------------------------

ts

    import { type PrepareEmailCampaignResponse } from '@iexec/web3mail';

### campaignRequest [â€‹](#campaignrequest)

**Type:** `BulkRequest`

The prepared bulk request object that contains all the necessary information to process the bulk campaign. This object should be passed to `sendEmailCampaign` to execute the campaign.

ts

    const { tasks } = await web3mail.sendEmailCampaign({
      campaignRequest: emailCampaign.campaignRequest, 
    });

Related Documentation [â€‹](#related-documentation)
-------------------------------------------------

*   [sendEmailCampaign Method](/references/web3mail/methods/sendEmailCampaign) - Send a prepared bulk campaign

sendEmailCampaign [â€‹](#sendemailcampaign)
=========================================

This method sends a bulk email campaign using a prepared campaign request. It processes a bulk request that has been created using the [`prepareEmailCampaign`](/references/web3mail/methods/prepareEmailCampaign) method.

Prerequisites

Before using this method, make sure you have:

1.  **Recipients granted access with bulk processing**: When calling [`grantAccess`](/references/dataProtector/methods/grantAccess) on the Data Protector SDK, recipients must set `allowBulk: true`
    
2.  **Prepared the campaign**: Use [`prepareEmailCampaign`](/references/web3mail/methods/prepareEmailCampaign) to create the bulk request that will be passed to this method
    

Usage [â€‹](#usage)
-----------------

BrowserNodeJS

ts

    import { IExecWeb3mail } from '@iexec/web3mail';
    import { type PrepareEmailCampaignResponse } from '@iexec/web3mail';
    import { type SendEmailCampaignResponse } from '@iexec/web3mail';
    
    const web3Provider = window.ethereum;
    const web3mail = new IExecWeb3mail(web3Provider);
    
    // Step 1: Fetch contacts and prepare the campaign
    const contacts = await web3mail.fetchMyContacts({ bulkOnly: true });
    const grantedAccessArray = contacts.map((contact) => contact.grantedAccess);
    
    const emailCampaign: PrepareEmailCampaignResponse =
      await web3mail.prepareEmailCampaign({
        grantedAccesses: grantedAccessArray,
        emailSubject: 'My email subject',
        emailContent: 'My email content',
      });
    
    // Step 2: Send the campaign
    const { tasks }: SendEmailCampaignResponse = await web3mail.sendEmailCampaign({
      campaignRequest: emailCampaign.campaignRequest,
      workerpoolAddressOrEns: '0xa5de76...',
    });

ts

    import { IExecWeb3mail, getWeb3Provider } from '@iexec/web3mail';
    import { type PrepareEmailCampaignResponse } from '@iexec/web3mail';
    import { type SendEmailCampaignResponse } from '@iexec/web3mail';
    
    const web3Provider = getWeb3Provider('PRIVATE_KEY');
    const web3mail = new IExecWeb3mail(web3Provider);
    
    // Step 1: Fetch contacts and prepare the campaign
    const contacts = await web3mail.fetchMyContacts({ bulkOnly: true });
    const grantedAccessArray = contacts.map((contact) => contact.grantedAccess);
    
    const emailCampaign: PrepareEmailCampaignResponse =
      await web3mail.prepareEmailCampaign({
        grantedAccesses: grantedAccessArray,
        emailSubject: 'My email subject',
        emailContent: 'My email content',
      });
    
    // Step 2: Send the campaign
    const { tasks }: SendEmailCampaignResponse = await web3mail.sendEmailCampaign({
      campaignRequest: emailCampaign.campaignRequest,
      workerpoolAddressOrEns: '0xa5de76...',
    });

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type SendEmailCampaignParams } from '@iexec/web3mail';

### campaignRequest Required \* [â€‹](#campaignrequest)

**Type:** `BulkRequest`

The bulk request object returned from `prepareEmailCampaign`. This contains all the necessary information to process the bulk campaign, including the grouped protected data and campaign metadata.

ts

    const { tasks } = await web3mail.sendEmailCampaign({
      campaignRequest: emailCampaign.campaignRequest, 
    });

### workerpoolAddressOrEns Optional [â€‹](#workerpooladdressorens)

**Type:** `AddressOrENS | undefined`

**Default:** Default workerpool from chain configuration

The workerpool address or ENS name that will execute the bulk campaign tasks.

ts

    const { tasks } = await web3mail.sendEmailCampaign({
      campaignRequest: emailCampaign.campaignRequest,
      workerpoolAddressOrEns: '0xa5de76...', 
    });

Return Value [â€‹](#return-value)
-------------------------------

ts

    import { type SendEmailCampaignResponse } from '@iexec/web3mail';

### tasks [â€‹](#tasks)

**Type:** `Array<{ taskId: string; dealId: string; bulkIndex: number }>`

An array of task objects created for the bulk processing campaign. Each task object contains:

*   `taskId`: The task ID created on the iExec network
*   `dealId`: The deal ID associated with the task
*   `bulkIndex`: The index of the task in the bulk request

Each task may process multiple protected data items depending on the bulk request configuration.

ts

    const { tasks } = await web3mail.sendEmailCampaign({
      campaignRequest: emailCampaign.campaignRequest,
    });

Related Documentation [â€‹](#related-documentation)
-------------------------------------------------

*   [grantAccess Method](/references/dataProtector/methods/grantAccess) - Grant access to protected data (recipients must set `allowBulk: true` to enable bulk processing)
*   [fetchMyContacts Method](/references/web3mail/methods/fetchMyContacts) - Fetch your contacts (use `bulkOnly: true` for bulk campaigns)
*   [fetchUserContacts Method](/references/web3mail/methods/fetchUserContacts) - Fetch contacts for a user (use `bulkOnly: true` for bulk campaigns)

Advanced Configuration [â€‹](#advanced-configuration)
===================================================

The `IExecWeb3mail` constructor accepts configuration options object. As these options are very specific, you won't need to use them for a standard usage of `@iexec/web3mail`.

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type Web3MailConfigOptions } from '@iexec/web3mail';

### dappAddressOrENS [â€‹](#dappaddressorens)

The Ethereum contract address or ENS (Ethereum Name Service) for the web3mail iApp.

ts

    const web3mail = new IExecWeb3mail(web3Provider, {
      dappAddressOrENS: '0x456def...', 
    });

### dappWhitelistAddress [â€‹](#dappwhitelistaddress)

The Ethereum contract address for the web3mail iApp whitelist. By granting access to a whitelist, email address owners ensure their email is still available to consumers even after a new version of web3mail iApp gets released.

If not provided, the default whitelist smart contract address provided by iExec will be used.

ts

    const web3mail = new IExecWeb3mail(web3Provider, {
      dappWhitelistAddress: '0x456def...', 
    });

### dataProtectorSubgraph [â€‹](#dataprotectorsubgraph)

The subgraph URL for querying data.

If not provided, the default data protector subgraph provided by iExec will be used.

ts

    const web3mail = new IExecWeb3mail(web3Provider, {
      dataProtectorSubgraph: 'subgraph-url', 
    });

### ipfsNode [â€‹](#ipfsnode)

The IPFS node URL for content uploads. Use this option if you want to use your own IPFS node to upload content.

If not provided, the default IPFS node provided by iExec will be used.

ts

    const web3mail = new IExecWeb3mail(web3Provider, {
      ipfsNode: 'ipfs-node-url', 
    });

### ipfsGateway [â€‹](#ipfsgateway)

The IPFS gateway URL used for content downloads. Mainly used for checking content uploaded on the IPFS network. Use this option if you want to use your own IPFS node for content downloads.

If not provided, the default IPFS gateway provided by iExec will be used.

ts

    const web3mail = new IExecWeb3mail(web3Provider, {
      ipfsGateway: 'ipfs-gateway-url', 
    });

### iexecOptions [â€‹](#iexecoptions)

Low level configuration options for `iexec` SDK, see [iexec SDK documentation IExecConfigOptions](https://github.com/iExecBlockchainComputing/iexec-sdk/blob/master/docs/interfaces/IExecConfigOptions.md) for more details.

ðŸ’¬ Web3Telegram [â€‹](#web3telegram)
==================================

Web3Telegram offers a secure method to manage telegram communications via the blockchain. This mechanism helps protect the personal information of the telegram chat ID recipients through use of Ethereum addresses.

iExec's protocol the telegram chat ID as a `protectedData` entity using [iExec Data Protector](/references/dataProtector). Through this mechanism, users have complete control over which applications may use their [chat ID](/guides/use-iapp/integrate-web3-messaging#retrieve-chat-id) for sending communications.

Sending a user a message, therefore, requires knowledge of the Ethereum address of their `protectedData` as well as an explicit authorization for your account to contact them. But also requires the receiver to send a telegram message to the bot first.

Your account may be bound to either an application or an individual. At any time a user may revoke permissions and this revocation is immediate, giving users complete control over the privacy and security of their information.

Apps using Web3Telegram can:

*   enable an entity (such as an application provider or an end-user) to message an Ethereum account holder with telegram without knowing their chat ID or username
*   grant users complete control over which entities are authorized to use their chat ID to send them communications

**Try the demo:**

[Web3Messaging Demo](https://demo.iex.ec/web3messaging)

Getting started [â€‹](#getting-started)
=====================================

[![GitHub package.json version (branch)](https://img.shields.io/github/package-json/v/iExecBlockchainComputing/web3telegram-sdk?color=green)](https://github.com/iExecBlockchainComputing/web3telegram-sdk)

Overview [â€‹](#overview)
-----------------------

### Prerequisites [â€‹](#prerequisites)

Before getting started, ensure that you have the following installed on your system:

\- [**Node.js**](https://nodejs.org/en/) version 18 or higher

\- [**NPM**](https://docs.npmjs.com/) (Node.js package manager)

### Installation [â€‹](#installation)

npmyarnpnpmbun

sh

    npm install @iexec/web3telegram

sh

    yarn add @iexec/web3telegram

sh

    pnpm add @iexec/web3telegram

sh

    bun add @iexec/web3telegram

**This package is an ESM package. Your project needs to use ESM too.** Â [**Read more**](https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c)

If you use it with **Webpack**, some polyfills will be needed. You will find a working project later.

### Instantiate SDK [â€‹](#instantiate-sdk)

BrowserNodeJS

ts

    import { IExecWeb3telegram } from '@iexec/web3telegram';
    
    const web3Provider = window.ethereum;
    // instantiate
    const web3telegram = new IExecWeb3telegram(web3Provider);

ts

    import { IExecWeb3telegram, getWeb3Provider } from '@iexec/web3telegram';
    
    // get web3 provider from a private key
    const web3Provider = getWeb3Provider('YOUR_PRIVATE_KEY');
    // instantiate
    const web3telegram = new IExecWeb3telegram(web3Provider);

Sandbox [â€‹](#sandbox)
---------------------

[âš¡ Â Code Sandbox](https://codesandbox.io/p/github/iExecBlockchainComputing/web3-telegram-sandbox/main)

Corresponding GitHub repository:

[ðŸ”Ž Â GitHub repository sandbox](https://github.com/iExecBlockchainComputing/web3-telegram-sandbox)

fetchMyContacts [â€‹](#fetchmycontacts)
=====================================

This method provides a list of `contact` objects identifying all users who previously granted authorization to send them telegram messages. Each contact contains the contact's ETH address as well as the ETH address for the `protectedData` containing their telegram chat ID.

Usage [â€‹](#usage)
-----------------

ts

    const contactsList = await web3telegram.fetchMyContacts();

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type FetchMyContactsParams } from '@iexec/web3telegram';

### isUserStrict Optional [â€‹](#isuserstrict)

**Type:** `boolean`

This parameter enables fetching contacts who granted access exclusively to the user and no one else.

TIP

When you grant access to someone, you can choose to grant access to a specific user (a wallet) or to any user (`0x0000000000000000000000000000000000000000`).

ts

    const contactsList = await web3telegram.fetchMyContacts({
      isUserStrict: true, 
    });

### bulkOnly Optional [â€‹](#bulkonly)

**Type:** `boolean`

**Default:** `false`

When set to `true`, this parameter filters contacts to only return those who have granted access with bulk processing capability. These contacts can be used with [`prepareTelegramCampaign`](/references/web3telegram/methods/prepareTelegramCampaign) and [`sendTelegramCampaign`](/references/web3telegram/methods/sendTelegramCampaign) for bulk campaigns.

ts

    const contactsList = await web3telegram.fetchMyContacts({
      bulkOnly: true, 
    });

Return Value [â€‹](#return-value)
-------------------------------

The result object contains a list of `contact` objects. Each `contact` represents one user who previously granted you authorization to send them messages.

ts

    import { type Contact } from '@iexec/web3telegram';

[`Contact[]`](/references/dataProtector/types#contact)

fetchUserContacts [â€‹](#fetchusercontacts)
=========================================

This method provides a list of `contact` objects identifying all entities who previously granted authorization to a specified entity to send them telegram messages. Each contact contains the contact's ETH address as well as the ETH address for the `protectedData` containing their telegram chat ID.

Usage [â€‹](#usage)
-----------------

ts

    const contactsList = await web3telegram.fetchUserContacts({
      userAddress: '0x789cba...',
    });

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type FetchUserContactsParams } from '@iexec/web3telegram';

### userAddress [â€‹](#useraddress)

**Type:** `Address`

The entity for which you wish to obtain the list of contacts.

ts

    const contactsList = await web3telegram.fetchUserContacts({
      userAddress: '0x789cba...', 
    });

### isUserStrict Optional [â€‹](#isuserstrict)

**Type:** `boolean`

This parameter enables fetching contacts who granted access exclusively to the user and no one else.

TIP

When someone grants access, you can choose to grant access to a specific user (a wallet) or to any user (`0x0000000000000000000000000000000000000000`).

ts

    const contactsList = await web3telegram.fetchUserContacts({
      userAddress: '0x789cba...',
      isUserStrict: true, 
    });

### bulkOnly Optional [â€‹](#bulkonly)

**Type:** `boolean`

**Default:** `false`

When set to `true`, this parameter filters contacts to only return those who have granted access with bulk processing capability. These contacts can be used with [`prepareTelegramCampaign`](/references/web3telegram/methods/prepareTelegramCampaign) and [`sendTelegramCampaign`](/references/web3telegram/methods/sendTelegramCampaign) for bulk campaigns.

ts

    const contactsList = await web3telegram.fetchUserContacts({
      userAddress: '0x789cba...',
      bulkOnly: true, 
    });

Return Value [â€‹](#return-value)
-------------------------------

The result object contains a list of `contact` objects. Each `contact` represents one user who previously granted authorization for the user identified with `userAddress` to send them messages.

ts

    import { type Contact } from '@iexec/web3telegram';

[`Contract[]`](/references/dataProtector/types#contact)

sendTelegram [â€‹](#sendtelegram)
===============================

This method allows an authorized entity to send a telegram message to a User without needing to know their username or Chat ID.

The recipient Chat ID is stored in a `protectedData` entity. The user receiving message must explicitly authorize you to send them telegram communications and permission must be granted for the `Web3Telegram` tool to use the `protectedData` entity containing their chat ID. This is best done by granting authorization to the Web3Telegram app whitelist `0x192C6f5AccE52c81Fcc2670f10611a3665AAA98F` as `authorizedApp`. Refer to the [Data Protector `grantAccess`](/references/dataProtector/methods/grantAccess) documentation for more details.

INFO

For sending bulk campaigns to multiple recipients, use [`prepareTelegramCampaign`](/references/web3telegram/methods/prepareTelegramCampaign) and [`sendTelegramCampaign`](/references/web3telegram/methods/sendTelegramCampaign).

TIP

For executing the `sendTelegram` method with RLC, refer to the dedicated section in the documentation under "[How to Pay for Executions](/guides/use-iapp/how-to-pay-executions)".

Usage [â€‹](#usage)
-----------------

ts

    
    const sendTelegram = await web3telegram.sendTelegram({
      protectedData: '0x123abc...',
      telegramContent: 'My telegram message content',
      senderName: 'Awesome project team',
      label: 'some-custom-id',
      dataMaxPrice: 42,
      appMaxPrice: 42,
      workerpoolMaxPrice: 42,
    });

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type SendTelegramParams } from '@iexec/web3telegram';

### protectedData [â€‹](#protecteddata)

**Type:** `Address`

The address of the `protectedData` holding the contact's telegram chat ID.

ts

    
    const sendTelegram = await web3telegram.sendTelegram({
      protectedData: '0x123abc...', 
      senderName: 'Arthur',
      telegramContent: 'My telegram message content',
    });

### senderName [â€‹](#sendername)

**Type:** `string`

The name of the telegram message sender.

ts

    
    const sendTelegram = await web3telegram.sendTelegram({
      protectedData: '0x123abc...',
      senderName: 'Arthur', 
      telegramContent: 'My telegram message content',
    });

### telegramContent [â€‹](#telegramcontent)

**Type:**`string` **Maximum siz:** `512 kb`

The telegram message content that needs to be sent. The content is limited to 512 kb in size. Telegram content is encrypted and stored in IPFS.

ts

    
    const sendTelegram = await web3telegram.sendTelegram({
      protectedData: '0x123abc...',
      senderName: 'Arthur',
      telegramContent: 'My telegram message content', 
    });

### label [â€‹](#label)

**Type:** `string | undefined`

Allows adding a custom public label. The Web3telegram tool writes this onchain as `iexec_args` in the deal params.

ts

    
    const sendTelegram = await web3telegram.sendTelegram({
      protectedData: '0x123abc...',
      senderName: 'Arthur',
      telegramContent: 'My telegram message content',
      label: 'some-custom-id', 
    });

### workerpoolAddressOrEns [â€‹](#workerpooladdressorens)

**Type:** `workerpoolAddressOrEns | undefined`

**Default:** `prod-v8-bellecour.main.pools.iexec.eth` (iExec's workerpool)

Allows specifying the workerpool that will run the Web3Telegram application.

ts

    
    const sendTelegram = await web3telegram.sendTelegram({
      protectedData: '0x123abc...',
      senderName: 'Arthur',
      telegramContent: 'My telegram message content',
      workerpoolAddressOrEns: '0xa5de76...', 
    });

### dataMaxPrice [â€‹](#datamaxprice)

**Type:** `number | undefined`

**Default:** `0`

Allows specifying the maximum amount (in nRLC) you are willing to pay the telegram chat ID owner for using their data. The owner of the protected chat ID receives this as a payment for sharing their data.

ts

    
    const sendTelegram = await web3telegram.sendTelegram({
      protectedData: '0x123abc...',
      senderName: 'Arthur',
      telegramContent: 'My telegram message content',
      dataMaxPrice: 42, 
    });

### appMaxPrice [â€‹](#appmaxprice)

**Type:** `number | undefined`

**Default:** `0`

Allows specifying the maximum amount (in nRLC) you are willing to pay the Web3telegram app provider (iExec) for using the Web3telegram application.

ts

    
    const sendTelegram = await web3telegram.sendTelegram({
      protectedData: '0x123abc...',
      senderName: 'Arthur',
      telegramContent: 'My telegram message content',
      appMaxPrice: 42, 
    });

### workerpoolMaxPrice [â€‹](#workerpoolmaxprice)

**Type:** `number | undefined`

**Default:** `0`

Allows specifying the maximum amount you want to pay the workerpool provider for using their infrastructure to run the web3telegram app in nRLC.

ts

    
    const sendTelegram = await web3telegram.sendTelegram({
      protectedData: '0x123abc...',
      senderName: 'Arthur',
      telegramContent: 'My telegram message content',
      workerpoolMaxPrice: 42, 
    });

Return Value [â€‹](#return-value)
-------------------------------

ts

    import { type SendTelegramResponse } from '@iexec/web3telegram';

### taskId [â€‹](#taskid)

**Type:** `Address`

This uniquely identifies the telegram task on the iExec side chain. You can view the status of the `sendTelegram` method by monitoring the task on the [iExec explorer](https://explorer.iex.ec/bellecour) .

prepareTelegramCampaign [â€‹](#preparetelegramcampaign)
=====================================================

This method prepares a bulk Telegram campaign by creating a bulk request that groups multiple protected data items. The prepared campaign request can then be sent using the [`sendTelegramCampaign`](/references/web3telegram/methods/sendTelegramCampaign) method.

INFO

This method is part of a two-step bulk campaign process:

1.  **Prepare the campaign** using `prepareTelegramCampaign` to create a bulk request
2.  **Send the campaign** using `sendTelegramCampaign` to process the bulk request

Usage [â€‹](#usage)
-----------------

BrowserNodeJS

ts

    import { IExecWeb3telegram } from '@iexec/web3telegram';
    
    const web3Provider = window.ethereum;
    const web3telegram = new IExecWeb3telegram(web3Provider);
    
    // Fetch contacts with bulk access
    const contacts = await web3telegram.fetchMyContacts({ bulkOnly: true });
    const grantedAccessArray = contacts.map((contact) => contact.grantedAccess);
    
    // Prepare the campaign
    const telegramCampaign = await web3telegram.prepareTelegramCampaign({
      grantedAccesses: grantedAccessArray,
      telegramContent: 'My telegram message content',
      senderName: 'Awesome project team',
    });

ts

    import { IExecWeb3telegram, getWeb3Provider } from '@iexec/web3telegram';
    
    const web3Provider = getWeb3Provider('PRIVATE_KEY');
    const web3telegram = new IExecWeb3telegram(web3Provider);
    
    // Fetch contacts with bulk access
    const contacts = await web3telegram.fetchMyContacts({ bulkOnly: true });
    const grantedAccessArray = contacts.map((contact) => contact.grantedAccess);
    
    // Prepare the campaign
    const telegramCampaign = await web3telegram.prepareTelegramCampaign({
      grantedAccesses: grantedAccessArray,
      telegramContent: 'My telegram message content',
      senderName: 'Awesome project team',
    });

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type PrepareTelegramCampaignParams } from '@iexec/web3telegram';

### grantedAccesses Required \* [â€‹](#grantedaccesses)

**Type:** `GrantedAccess[]`

An array of `GrantedAccess` objects representing contacts who have granted you access to their protected data with bulk processing capability.

ts

    const telegramCampaign = await web3telegram.prepareTelegramCampaign({
      grantedAccesses: grantedAccessArray, 
      telegramContent: 'My message',
      senderName: 'My App',
    });

### telegramContent Required \* [â€‹](#telegramcontent)

**Type:** `string`

**Maximum size:** `512 kb`

The telegram message content that will be sent to all recipients. The content is encrypted and stored in IPFS.

ts

    const telegramCampaign = await web3telegram.prepareTelegramCampaign({
      grantedAccesses: grantedAccessArray,
      telegramContent: 'My telegram message content', 
      senderName: 'Awesome project team',
    });

### senderName Optional [â€‹](#sendername)

**Type:** `string | undefined`

The name of the telegram message sender that will be displayed to recipients.

ts

    const telegramCampaign = await web3telegram.prepareTelegramCampaign({
      grantedAccesses: grantedAccessArray,
      telegramContent: 'My telegram message content',
      senderName: 'Awesome project team', 
    });

### maxProtectedDataPerTask Optional [â€‹](#maxprotecteddatapertask)

**Type:** `number | undefined`

**Default:** `100`

Limits the number of protected data items processed per task.

ts

    const telegramCampaign = await web3telegram.prepareTelegramCampaign({
      grantedAccesses: grantedAccessArray,
      telegramContent: 'My telegram message content',
      senderName: 'Awesome project team',
      maxProtectedDataPerTask: 10, 
    });

### workerpoolAddressOrEns Optional [â€‹](#workerpooladdressorens)

**Type:** `AddressOrENS | undefined`

**Default:** Default workerpool from chain configuration

The workerpool address or ENS name that will execute the bulk campaign tasks. You can specify this during preparation or when sending the campaign.

ts

    const telegramCampaign = await web3telegram.prepareTelegramCampaign({
      grantedAccesses: grantedAccessArray,
      telegramContent: 'My telegram message content',
      senderName: 'Awesome project team',
      workerpoolAddressOrEns: '0xa5de76...', 
    });

### workerpoolMaxPrice Optional [â€‹](#workerpoolmaxprice)

**Type:** `number | undefined`

**Default:** `0`

The maximum amount (in nRLC) you are willing to pay the workerpool provider for using their infrastructure to run the Web3Telegram app. You can specify this during preparation or when sending the campaign.

ts

    const telegramCampaign = await web3telegram.prepareTelegramCampaign({
      grantedAccesses: grantedAccessArray,
      telegramContent: 'My telegram message content',
      senderName: 'Awesome project team',
      workerpoolMaxPrice: 0.1 * 1e9, 
    });

### label Optional [â€‹](#label)

**Type:** `string | undefined`

An optional label to identify or categorize the campaign.

ts

    const telegramCampaign = await web3telegram.prepareTelegramCampaign({
      grantedAccesses: grantedAccessArray,
      telegramContent: 'My telegram message content',
      senderName: 'Awesome project team',
      label: 'Newsletter Campaign', 
    });

### dataMaxPrice Optional [â€‹](#datamaxprice)

**Type:** `number | undefined`

**Default:** `0`

The maximum amount (in nRLC) you are willing to pay for accessing the protected data.

ts

    const telegramCampaign = await web3telegram.prepareTelegramCampaign({
      grantedAccesses: grantedAccessArray,
      telegramContent: 'My telegram message content',
      senderName: 'Awesome project team',
      dataMaxPrice: 0.1 * 1e9, 
    });

### appMaxPrice Optional [â€‹](#appmaxprice)

**Type:** `number | undefined`

**Default:** `0`

The maximum amount (in nRLC) you are willing to pay the Web3Telegram app provider for using the Web3Telegram application.

ts

    const telegramCampaign = await web3telegram.prepareTelegramCampaign({
      grantedAccesses: grantedAccessArray,
      telegramContent: 'My telegram message content',
      senderName: 'Awesome project team',
      appMaxPrice: 0.1 * 1e9, 
    });

Return Value [â€‹](#return-value)
-------------------------------

ts

    import { type PrepareTelegramCampaignResponse } from '@iexec/web3telegram';

### campaignRequest [â€‹](#campaignrequest)

**Type:** `BulkRequest`

The prepared bulk request object that contains all the necessary information to process the bulk campaign. This object should be passed to `sendTelegramCampaign` to execute the campaign.

ts

    const { tasks } = await web3telegram.sendTelegramCampaign({
      campaignRequest: telegramCampaign.campaignRequest, 
    });

Related Documentation [â€‹](#related-documentation)
-------------------------------------------------

*   [sendTelegramCampaign Method](/references/web3telegram/methods/sendTelegramCampaign) - Send a prepared bulk campaign

sendTelegramCampaign [â€‹](#sendtelegramcampaign)
===============================================

This method sends a bulk Telegram campaign using a prepared campaign request. It processes a bulk request that has been created using the [`prepareTelegramCampaign`](/references/web3telegram/methods/prepareTelegramCampaign) method.

Prerequisites

Before using this method, make sure you have:

1.  **Recipients granted access with bulk processing**: When calling [`grantAccess`](/references/dataProtector/methods/grantAccess) on the Data Protector SDK, recipients must set `allowBulk: true`
    
2.  **Prepared the campaign**: Use [`prepareTelegramCampaign`](/references/web3telegram/methods/prepareTelegramCampaign) to create the bulk request that will be passed to this method
    

Usage [â€‹](#usage)
-----------------

BrowserNodeJS

ts

    import { IExecWeb3telegram } from '@iexec/web3telegram';
    import { type SendTelegramCampaignResponse } from '@iexec/web3telegram';
    
    const web3Provider = window.ethereum;
    const web3telegram = new IExecWeb3telegram(web3Provider);
    
    // Step 1: Fetch contacts and prepare the campaign
    const contacts = await web3telegram.fetchMyContacts({ bulkOnly: true });
    const grantedAccessArray = contacts.map((contact) => contact.grantedAccess);
    
    const telegramCampaign = await web3telegram.prepareTelegramCampaign({
      grantedAccesses: grantedAccessArray,
      telegramContent: 'My telegram message content',
      senderName: 'Awesome project team',
    });
    
    // Step 2: Send the campaign
    const { tasks }: SendTelegramCampaignResponse =
      await web3telegram.sendTelegramCampaign({
        campaignRequest: telegramCampaign.campaignRequest,
        workerpoolAddressOrEns: '0xa5de76...',
      });

ts

    import { IExecWeb3telegram, getWeb3Provider } from '@iexec/web3telegram';
    import { type SendTelegramCampaignResponse } from '@iexec/web3telegram';
    
    const web3Provider = getWeb3Provider('PRIVATE_KEY');
    const web3telegram = new IExecWeb3telegram(web3Provider);
    
    // Step 1: Fetch contacts and prepare the campaign
    const contacts = await web3telegram.fetchMyContacts({ bulkOnly: true });
    const grantedAccessArray = contacts.map((contact) => contact.grantedAccess);
    
    const telegramCampaign = await web3telegram.prepareTelegramCampaign({
      grantedAccesses: grantedAccessArray,
      telegramContent: 'My telegram message content',
      senderName: 'Awesome project team',
    });
    
    // Step 2: Send the campaign
    const result: SendTelegramCampaignResponse =
      await web3telegram.sendTelegramCampaign({
        campaignRequest: telegramCampaign.campaignRequest,
        workerpoolAddressOrEns: '0xa5de76...',
      });

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type SendTelegramCampaignParams } from '@iexec/web3telegram';

### campaignRequest Required \* [â€‹](#campaignrequest)

**Type:** `BulkRequest`

The bulk request object returned from `prepareTelegramCampaign`. This contains all the necessary information to process the bulk campaign, including the grouped protected data and campaign metadata.

ts

    const { tasks } = await web3telegram.sendTelegramCampaign({
      campaignRequest: telegramCampaign.campaignRequest, 
    });

### workerpoolAddressOrEns Optional [â€‹](#workerpooladdressorens)

**Type:** `string | undefined`

**Default:** Default workerpool from chain configuration

The workerpool address or ENS name that will execute the bulk campaign tasks.

ts

    const { tasks } = await web3telegram.sendTelegramCampaign({
      campaignRequest: telegramCampaign.campaignRequest,
      workerpoolAddressOrEns: '0xa5de76...', 
    });

Return Value [â€‹](#return-value)
-------------------------------

ts

    import { type SendTelegramCampaignResponse } from '@iexec/web3telegram';

### tasks [â€‹](#tasks)

**Type:** `Array<{ bulkIndex: number; taskId: string; dealId: string }>`

An array of task objects created for the bulk processing campaign. Each task object contains:

*   `bulkIndex`: The index of the bulk request within the campaign
*   `taskId`: The task ID created on the iExec network
*   `dealId`: The deal ID associated with the task

Each task may process multiple protected data items depending on the bulk request configuration.

ts

    const { tasks } = await web3telegram.sendTelegramCampaign({
      campaignRequest: telegramCampaign.campaignRequest,
    });

Related Documentation [â€‹](#related-documentation)
-------------------------------------------------

*   [grantAccess Method](/references/dataProtector/methods/grantAccess) - Grant access to protected data (recipients must set `allowBulk: true` to enable bulk processing)
*   [fetchMyContacts Method](/references/web3telegram/methods/fetchMyContacts) - Fetch your contacts (use `bulkOnly: true` for bulk campaigns)
*   [fetchUserContacts Method](/references/web3telegram/methods/fetchUserContacts) - Fetch contacts for a user (use `bulkOnly: true` for bulk campaigns)

Advanced Configuration [â€‹](#advanced-configuration)
===================================================

The `IExecWeb3Telegram` constructor accepts configuration options object. As these options are very specific, you won't need to use them for a standard usage of `@iexec/web3telegram`.

Parameters [â€‹](#parameters)
---------------------------

ts

    import { type Web3TelegramConfigOptions } from '@iexec/web3telegram';

### dappAddressOrENS [â€‹](#dappaddressorens)

The Ethereum contract address or ENS (Ethereum Name Service) for the web3telegram iApp.

If not provided, the default ENS web3telegram iApp provided by iExec will be used.

ts

    const web3telegram = new IExecWeb3telegram(web3Provider, {
      dappAddressOrENS: '0x456def...', 
    });

### dappWhitelistAddress [â€‹](#dappwhitelistaddress)

The Ethereum contract address for the web3telegram iApp whitelist. By granting access to a whitelist, Chat Id owners ensure their Chat Id is still available to consumers even after a new version of web3telegram iApp gets released.

If not provided, the default whitelist smart contract address provided by iExec will be used.

ts

    const web3telegram = new IExecWeb3telegram(web3Provider, {
      dappWhitelistAddress: '0x456def...', 
    });

### dataProtectorSubgraph [â€‹](#dataprotectorsubgraph)

The subgraph URL for querying data.

If not provided, the default data protector subgraph provided by iExec will be used.

ts

    const web3telegram = new IExecWeb3telegram(web3Provider, {
      dataProtectorSubgraph: 'subgraph-url', 
    });

### ipfsNode [â€‹](#ipfsnode)

The IPFS node URL for content uploads. Use this option if you want to use your own IPFS node to upload content.

If not provided, the default IPFS node provided by iExec will be used.

ts

    const web3telegram = new IExecWeb3telegram(web3Provider, {
      ipfsNode: 'ipfs-node-url', 
    });

### ipfsGateway [â€‹](#ipfsgateway)

The IPFS gateway URL used for content downloads. Mainly used for checking content uploaded on the IPFS network. Use this option if you want to use your own IPFS node for content downloads.

If not provided, the default IPFS gateway provided by iExec will be used.

ts

    const web3telegram = new IExecWeb3telegram(web3Provider, {
      ipfsGateway: 'ipfs-gateway-url', 
    });

### iexecOptions [â€‹](#iexecoptions)

Low level configuration options for `iexec` SDK, see [iexec SDK documentation IExecConfigOptions](https://github.com/iExecBlockchainComputing/iexec-sdk/blob/master/docs/interfaces/IExecConfigOptions.md) for more details.