Hack4Privacy MVP Spec — ShadowPool (Confidential Batch Trading with Uniswap v4 Hook Enforcement)
=============================================================================================
Version: 2026-02-02
Document type: MVP specification (implementation-aligned)

0) Table of contents
1) Summary and goals
2) MVP scope (in / out)
3) Roles and permissions model
4) User journeys and acceptance criteria
5) Product surface (screens + required UI behaviors)
6) End-to-end system architecture
7) Data formats and cryptographic commitments
8) On-chain specification (IntentRegistry, ShadowPoolRootRegistry, ShadowPoolHook)
9) Confidential iApp specification (TEE matcher)
10) Frontend orchestration specification
11) Configuration reference (env + chain requirements)
12) Deployment and operations runbook (MVP)
13) Testing and QA gates (MVP)
14) Demo checklist (recording-ready)
15) Security and privacy requirements (MVP)

1) Summary and goals
1.1 One-sentence pitch
ShadowPool is a privacy-preserving batch trading terminal where limit-style intents are encrypted client-side with iExec DataProtector, matched inside a TEE iApp, and executed on-chain only if a Uniswap v4 hook validates a TEE-signed Merkle-proof authorization.

1.2 Problem statement
Public mempools leak trading intent (size/price/direction/timing), enabling MEV (front-running, sandwiching) and strategy copying. ShadowPool keeps intent parameters confidential during the matching phase while still enforcing that only approved matches can settle on-chain.

1.3 MVP objectives (must-have outcomes)
- Confidentiality during matching: no limit price/size/strategy is published on-chain pre-match.
- Verifiable settlement: swaps are rejected unless authorized by (round root + Merkle proof + TEE signature).
- Batch processing: a single matching run processes a list of encrypted intents (bulk workflow).
- Demoability: a clear 3-step UX (Protect → Grant → Submit), an admin “Run round + Post root”, and a trader “Execute swap”.

1.5 Milestones (repo-aligned)
- Milestone 1 — On-chain + UI intake: deploy contracts, Protect/Grant/Submit works end-to-end.
- Milestone 2 — Matching: run bulk TEE matcher and surface matches + Merkle root in UI.
- Milestone 3 — Root posting: close round and post root on-chain, round becomes executable.
- Milestone 4 — Execution + replay: execute via Uniswap v4 hook; replay attempts revert.

1.6 Open gaps (as of 2026-02-06)
- On-chain minAmountOut enforcement is disabled in the hook; UI checks it post-swap.
- Frontend does not sign matches if iApp does not provide signatures (requires iApp signing).
- Root posting requires the RootRegistry owner to call closeRound; admin wallet must be owner.

1.4 Bounty alignment checklist (current)
- Confidential DeFi focus: private intent parameters (price/size/slippage/notes) during matching
- Uses iExec privacy tech: DataProtector (protect/grant) + TEE iApp (confidential computation)
- Bulk processing: batch round matching via DataProtector bulk requests
- Optional bonus (not required for MVP): Account Abstraction / gas sponsorship for execution
- Deploy target: Arbitrum Sepolia (chainId 421614) + public repo + demo video (+ feedback.md if required by submission rules)

2) MVP scope (in / out)
2.1 In scope (MVP)
- Frontend terminal (React) supporting:
  - intent creation (buy/sell), token pair selection, amount, limit price, expiry
  - DataProtector protectData + grantAccess with allowBulk=true
  - on-chain submission to a round via IntentRegistry.registerIntent
  - admin round execution: run TEE matching and post Merkle root to ShadowPoolRootRegistry
  - trade execution: generate hook data and execute a swap via a Uniswap v4 test harness
- On-chain contracts (Arbitrum Sepolia):
  - IntentRegistry for round-scoped intent registration (public index without private fields)
  - ShadowPoolRootRegistry for round roots + root posting controls
  - ShadowPoolHook enforcing validity in Uniswap v4 swap path (beforeSwap/afterSwap)
- TEE iApp:
  - decrypt intents in a TEE, match deterministically, output matches + merkleRoot, optionally sign matches

2.2 Out of scope (MVP)
- Production-grade dark pool economics (fees, RFQ, sophisticated auction rules, multi-venue routing)
- On-chain order book, cancel/replace intents, partial reveal schemes, dispute games
- Permissionless keeper network; in MVP the admin UI can act as keeper
- Full Account Abstraction integration (unless explicitly added)
- Mainnet deployments, audits, and production privacy hardening beyond MVP requirements

2.3 Non-negotiable constraints
- Do not publish private intent fields on-chain (price/amount/expiry/salt/notes).
- Do not embed or commit secrets into the repo. Any private keys must be local-only.
- Hook enforcement must be the final gate for swap execution in the MVP demo.

3) Roles and permissions model
3.1 Roles
- Trader: creates intents and executes matched swaps.
- Intent owner: ProtectedData owner (usually the trader wallet) controlling grants.
- Requester (authorizedUser): wallet allowed to trigger the TEE computation for a ProtectedData item.
- Authorized app (authorizedApp): iExec iApp address or whitelist allowed to decrypt ProtectedData in the TEE.
- Matcher: the wallet that posts the first root for a round in ShadowPoolRootRegistry; subsequent root updates for that round must come from the same matcher.
- Hook owner: owner of the ShadowPoolHook contract (can update teeSigner and allowed callers).
- RootRegistry owner: can close rounds (enables root posting).

3.2 Trust model (MVP)
- Confidentiality relies on: DataProtector encryption + execution inside TEE.
- Correctness relies on: deterministic matching + TEE signing key integrity.
- Enforceability relies on: ShadowPoolHook validating proof + signature at swap time.

4) User journeys and acceptance criteria
4.1 Journey A — Trader creates and submits a confidential intent
Steps:
1) Trader connects wallet (Arbitrum Sepolia).
2) Trader fills intent form:
   - side: buy|sell
   - tokenPair: base/quote
   - amount (base amount)
   - limitPrice
   - expiry
   - optional: slippage bounds and private notes
3) Trader protects intent (DataProtector) and receives protectedDataAddress.
4) Trader grants bulk access to the configured iExec app + requester wallet.
5) Trader submits on-chain reference:
   - IntentRegistry.registerIntent(roundId, protectedDataAddress, commitment)

Acceptance criteria:
- On-chain event does not contain limitPrice/amount/expiry; only protectedData + commitment + trader + roundId.
- The UI shows a “protected” state with protectedDataAddress and an “on-chain submitted” tx hash.

4.2 Journey B — Admin runs matching round (TEE + bulk) and posts root
Steps:
1) Admin opens a specific round (roundId).
2) Admin loads submitted intents by reading IntentRegistered events for roundId.
3) Admin triggers runBatchRound:
   - verifies bulk access exists for each protectedData address
   - prepares a bulk request (args include roundId)
   - processes bulk request with waitForResult=true
4) Admin receives iApp output: matches[], merkleRoot, roundExpiry.
5) Admin posts round root:
   - ShadowPoolRootRegistry.closeRound(roundId) (owner-only)
   - ShadowPoolRootRegistry.postRoot(roundId, merkleRoot, validUntil)

Acceptance criteria:
- Matching output is deterministic given fixed inputs (and NOW_SECONDS override where used).
- Posted root is readable on-chain; UI indicates the round is now executable.
- Replay protection exists: attempting to execute the same match twice fails.

4.3 Journey C — Trader executes a matched trade (hook-gated)
Steps:
1) Trader selects a match and generates hook payload (proof + signature).
2) Trader executes a swap call using the configured execution harness.
3) Hook verifies: root active, match not expired, signature valid, membership proof valid, swap amount matches, and then marks the match as used.
4) In the current repo, the UI additionally checks output meets minAmountOut post-swap (the hook does not enforce it on-chain).

Acceptance criteria:
- Executing a swap without valid proof/signature reverts.
- A valid swap succeeds and consumes the match (subsequent attempts revert).

5) Product surface (screens + required UI behaviors)
Frontend project: shadow-pool-terminal (Vite + React + TypeScript).

MVP screens (routes) and minimum behaviors:
5.1 Landing
- Explains the flow: Protect → Grant → Match → Execute.
- Clear CTA to “Create Intent”.

5.2 Create Intent
- Form with validation for required fields (amount, limitPrice, expiry, token pair).
- Step UI states:
  - Step 1: Protect (creates ProtectedData)
  - Step 2: Grant (creates bulk access permissions)
  - Step 3: Submit (registers on-chain intent reference)
- Must clearly display:
  - protectedDataAddress
  - commitment (bytes32) used for on-chain reference
  - tx hash of IntentRegistry.registerIntent

5.3 Rounds list
- Displays auto-derived roundIds and/or roundIds seen on-chain.
- Shows per-round status: intake / matching / executable / completed.
- Shows intents count by reading events.

5.4 Round detail
- Shows round timeline and submitted intents (public references only).
- Admin actions (gated by admin mode):
  - Run TEE matching
  - Post Merkle root
- Displays merkleRoot and validUntil once posted.
- Displays matches list (locally stored) with proof availability and execution status.

5.5 Execute
- Lists executable matches (proof available + not expired + not executed).
- Shows decoded hook payload (for demo transparency).
- Executes a swap transaction and reports outcome.

5.6 Settings
- Admin mode toggle (optionally restricted by VITE_ADMIN_ADDRESS).
- Show/hide technical details toggle for demo friendliness.

6) End-to-end system architecture
6.1 Components (repo mapping)
A) Frontend dApp: shadow-pool-terminal
- Primary service layer: src/services/shadowPool.ts
  - protectData()
  - grantAccess()
  - submitToRound()
  - runBatchRound()
  - postRoundRoot()
  - generateHookData()
  - executeTradeWithProof()

B) On-chain: shadowpool-hook (Foundry)
- IntentRegistry.sol: public index of intent references and round schedule enforcement.
- ShadowPoolRootRegistry.sol: stores per-round Merkle root (with expiry) and root posting controls.
- ShadowPoolHook.sol: Uniswap v4 hook that validates authorization at swap-time.
- DeployShadowPool.s.sol: deploys core demo stack (pool manager, hook, registries, tokens, liquidity).

C) Confidential iApp: shadowpool-iapp
- src/app.js: reads protected inputs, matches, computes Merkle root, optionally signs.
- Produces: result.json + computed.json (iExec output requirements).

6.2 Networks (two contexts)
- EVM settlement network: Arbitrum Sepolia (chainId 421614)
  - IntentRegistry / ShadowPoolRootRegistry / Uniswap v4 contracts live here.
- iExec execution network: configurable
  - Default integration path in the frontend supports Arbitrum Sepolia.
  - Bellecour (chainId 0x86) is supported for xRLC-funded flows.

6.3 High-level sequence (MVP)
Trader:
  Protect intent (client-side encryption) -> protectedDataAddress
  Grant access (authorizedApp + authorizedUser, allowBulk=true)
  Submit on-chain reference (protectedDataAddress + commitment + roundId)

Admin:
  Collect protectedDataAddress list for roundId
  Trigger bulk TEE processing (args include roundId, secrets may include signing key)
  Receive matches + merkleRoot
  Close round + post merkleRoot to ShadowPoolRootRegistry with validUntil

Trader:
  Build Merkle proof for selected match
  Execute swap; hook validates proof/signature/expiry and consumes match

7) Data formats and cryptographic commitments
7.1 Intent protected data (private)
Stored via DataProtector as a JSON object (the SDK auto-generates schema from structure).

Canonical intent payload (as used by the frontend):
{
  "name": "iExec ShadowPool Intent",
  "data": {
    "version": "1",
    "trader": "0x...",
    "side": "buy" | "sell",
    "baseToken": "0x...",
    "quoteToken": "0x...",
    "amountBase": "string",
    "limitPrice": "string",
    "expiry": "number (unix seconds)",
    "salt": "0x... (bytes32 hex)",
    "tokenPair": {
      "base": { "address": "0x...", "decimals": 18, "symbol": "..." },
      "quote": { "address": "0x...", "decimals": 18, "symbol": "..." }
    },
    "amount": "string",
    "slippageMin": "string | number (optional)",
    "slippageMax": "string | number (optional)",
    "notes": "string (optional)"
  }
}

7.2 Intent commitment (public)
The frontend computes a commitment binding key fields without revealing them on-chain.

commitment = keccak256(abi.encode(
  sideAsUint8,           // 0=buy, 1=sell
  trader,                // address
  baseToken,             // address
  quoteToken,            // address
  amountBaseWei,         // uint256 (amountBase parsed using base decimals)
  limitPriceWad,         // uint256 (limitPrice parsed as 18-decimal wad)
  expirySeconds,         // uint64
  saltBytes32            // bytes32
))

Public on-chain storage contains only:
- protectedDataAddress (address)
- commitment (bytes32)
- roundId (bytes32)
- trader (address)

7.3 Round identity (public)
Round IDs are derived on-chain by IntentRegistry:
roundId = keccak256(abi.encode(roundNamespace, roundStartSeconds))
where roundStartSeconds = floor(block.timestamp / roundDurationSeconds) * roundDurationSeconds.

7.4 Match identifiers and leaf schema (public commitment)
Each executable swap requires an authorization leaf that is committed in the posted Merkle root.

matchIdString is a deterministic, human-readable identifier produced by the matcher (e.g., "fill:3:buy:0x...:0x...").
matchIdHash = keccak256(bytes(matchIdString))

leaf = keccak256(abi.encode(
  roundId,
  matchIdHash,
  trader,
  counterparty,
  tokenIn,
  tokenOut,
  amountIn,
  minAmountOut,
  expiry
))

Merkle tree rules (as enforced by the hook):
- Leaves are combined with sorted-pair hashing (order-independent):
  parent = keccak256(min(left,right) || max(left,right))
- Proof verification follows the same sorted rule for each sibling step.

7.5 Signature semantics (TEE signer)
The hook validates an ECDSA signature by teeSigner over the leaf (EIP-191 eth_sign style):
digest = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", leaf))
signature must recover to teeSigner.

8) On-chain specification (Arbitrum Sepolia)
8.1 IntentRegistry (IntentRegistry.sol)
Purpose:
- Publish a public index of submitted intents without revealing private fields.
- Enforce round schedule and intake window.

Key storage:
- roundNamespace: string
- roundDurationSeconds: uint64
- intakeWindowSeconds: uint64
- intents[intentId] = { protectedData, commitment, roundId, trader, timestamp }

Key functions (MVP):
- computeRoundId(uint64 roundStartSeconds) -> bytes32
- currentRoundStartSeconds() -> uint64
- roundConfig() -> (namespace, durationSeconds, intakeSeconds)
- registerIntent(bytes32 roundId, address protectedData, bytes32 commitment) -> uint256 intentId

Constraints:
- roundId must equal computeRoundId(currentRoundStartSeconds()) at time of call.
- block.timestamp must be strictly within intake window:
  block.timestamp < startSeconds + intakeWindowSeconds

Key events:
- IntentRegistered(roundId, trader, protectedData, commitment, position, intentId, timestamp)

8.2 ShadowPoolRootRegistry (ShadowPoolRootRegistry.sol)
Purpose:
- Provide a single source of truth for which batch roots are active.
- Control which matcher may post/update the root for a given round.

Key storage:
- roots[roundId] = bytes32
- rootValidUntil[roundId] = uint256
- matcher[roundId] = address
- rootLocked[roundId] = bool
- roundClosed[roundId] = bool

Key functions (MVP):
- closeRound(bytes32 roundId) (owner-only)
- postRoot(bytes32 roundId, bytes32 root, uint256 validUntil)
  - round must be closed and root must not be locked
  - if matcher is unset for the round, the first poster becomes matcher
  - otherwise only the existing matcher can post updates for that round
- lockRoot(bytes32 roundId) (matcher-only)
- getRoundInfo(bytes32 roundId) -> (root, validUntil, matcher, rootLocked, roundClosed, rootActive)

Key events:
- RootPosted(roundId, root, validUntil)
- MatcherSet(roundId, matcher)
- RootLockedForRound(roundId)
- RoundClosedByOwner(roundId)

8.3 ShadowPoolHook (ShadowPoolHook.sol)
Purpose:
- Enforce that only authorized matches can execute as swaps in Uniswap v4.

Key storage:
- owner: address
- teeSigner: address
- rootRegistry: ShadowPoolRootRegistry
- allowedCaller[address] = bool
- matchUsed[roundId][matchIdHash] = bool
- leafUsed[roundId][leaf] = bool

Admin functions (MVP):
- transferOwnership(address newOwner) (owner-only)
- setTeeSigner(address newSigner) (owner-only)
- setAllowedCaller(address caller, bool allowed) (owner-only)

Hook auth payload (ABI-decoded from hookData):
HookAuth {
  bytes32 roundId;
  bytes32 matchIdHash;
  address trader;
  address counterparty;
  address tokenIn;
  address tokenOut;
  uint256 amountIn;
  uint256 minAmountOut;
  uint256 expiry;
  bytes32[] merkleProof;
  bytes signature;
}

beforeSwap checks (MVP):
- sender must equal trader OR sender must be in allowedCallers
- block.timestamp <= expiry
- RootRegistry.getRoot(roundId) must exist and not be expired:
  root != 0 AND block.timestamp <= validUntil
- pool tokens must match tokenIn/tokenOut for swap direction
- swap must be exact-input with amountSpecified == -amountIn
- signature must be valid for digest(leaf)
- Merkle proof must validate leaf under root
- marks matchIdHash and leaf as used in hook storage (replay protection)

afterSwap checks (MVP):
- output amount check is not enforced on-chain in the current repo; UI performs a post-swap check

9) Confidential iApp specification (TEE matcher)
Project: shadowpool-iapp/shadowpool-iapp

9.1 Inputs
- Protected data files provided by iExec bulk workflow in the iExec input directory.
- Public args must contain roundId (bytes32 hex):
  args: JSON string like { "roundId": "0x..." } (preferred)

9.2 Outputs (result.json)
The deterministic output must include:
{
  "roundId": "0x..." | null,
  "roundIdBytes32": "0x..." | null,
  "intentsCount": number,
  "eligibleIntentsCount": number,
  "merkleRoot": "0x...",
  "roundExpiry": number | null,
  "matches": [
    {
      "matchId": "0x...",
      "trader": "0x...",
      "counterparty": "0x...",
      "tokenIn": "0x...",
      "tokenOut": "0x...",
      "amountIn": "string (uint256)",
      "minAmountOut": "string (uint256)",
      "expiry": number,
      "leaf": "0x...",
      "signature": "0x..." | null
    }
  ]
}

9.3 Matching algorithm (MVP)
- Parse and validate intent fields:
  - trader must be a valid address
  - side must be buy|sell
  - baseToken/quoteToken must be valid addresses
  - amountBase and limitPrice must exist and parse to positive values
- Expiry filtering:
  - ignore intents where expiry <= nowSeconds()
- Sorting:
  - buys sorted by descending priceWad (then stable by input order)
  - sells sorted by ascending priceWad (then stable by input order)
- Match rule:
  - token pair and decimals must match (baseToken, quoteToken, baseDecimals, quoteDecimals)
  - buy.priceWad >= sell.priceWad
- Fill rule:
  - baseAmountWei = min(buy.remainingBaseWei, sell.remainingBaseWei)
  - quoteAmountWei derived from baseAmountWei * sell.priceWad, adjusted for decimals
- Output:
  - emits two match legs per fill (buyer and seller) with deterministic amounts
  - merkleRoot is computed from all leaves using sorted-pair tree hashing
  - roundExpiry is min(expiry across emitted matches) or null if no matches

9.4 Signing model (MVP)
- If a signing key is available in the TEE environment, iApp outputs signature per match.
- Otherwise the frontend can sign missing signatures using VITE_TEE_PRIVATE_KEY as a demo fallback.

10) Frontend orchestration specification
10.1 Responsibilities
- Serve as the orchestrator for the MVP:
  - interact with DataProtector SDK (protect, grant, bulk prepare/process)
  - index on-chain intent references via events
  - post roots to ShadowPoolRootRegistry
  - generate proofs locally and build hook calldata
  - execute swaps via the configured harness

10.2 Error handling requirements (MVP)
The UI must surface clear, actionable errors for:
- iExec app misconfiguration (missing/invalid app address or whitelist)
- missing AppOrder / WorkerpoolOrder on the chosen iExec chain (price caps, restrictions)
- missing bulk access grants for the current requester wallet
- missing signatures (require VITE_TEE_PRIVATE_KEY fallback if iApp doesn’t sign)
- expired rounds/matches and already-consumed matches

11) Configuration reference (env + chain requirements)
11.1 Frontend (shadow-pool-terminal)
Core toggles:
- VITE_USE_IEXEC=true

Round schedule:
- VITE_ROUND_NAMESPACE (default "shadowpool")
- VITE_ROUND_DURATION_SECONDS (default 3600)

Arbitrum Sepolia RPC (optional but recommended):
- VITE_RPC_URL (default "https://arb-sepolia.g.alchemy.com/v2/lB78AtqzCmwOOeJqlKXYa")

iExec:
- VITE_IEXEC_APP_WHITELIST or VITE_IEXEC_APP or VITE_IEXEC_APP_ADDRESS (authorized app for grants)
- VITE_IEXEC_APP_ADDRESS or VITE_IEXEC_APP (execution app for bulk request)
- VITE_IEXEC_CHAIN_ID (optional; default is Arbitrum Sepolia chain id)
- VITE_IEXEC_RPC_URL (optional override)
- VITE_IEXEC_APP_MAX_PRICE (optional)
- VITE_IEXEC_WORKERPOOL_MAX_PRICE (optional)
- VITE_IEXEC_RESULT_PATH (optional; default "result.json")
- VITE_IEXEC_MATCH_TIMEOUT_MS (optional; default 15 minutes)
- VITE_IEXEC_AUTHORIZED_USER (optional override for requester checks)

TEE signing (demo fallback):
- VITE_TEE_PRIVATE_KEY (optional; used to sign matches in the frontend if the iApp output lacks signatures)

Contracts (Arbitrum Sepolia):
- VITE_SHADOWPOOL_INTENT_REGISTRY_ADDRESS
- VITE_SHADOWPOOL_ROOT_REGISTRY_ADDRESS (VITE_SHADOWPOOL_CLEARINGHOUSE_ADDRESS is accepted as an alias)
- VITE_SHADOWPOOL_HOOK_ADDRESS
- VITE_POOL_SWAP_TEST_ADDRESS
- VITE_POOL_FEE
- VITE_POOL_TICK_SPACING

Tokens (optional; used for token picker):
- VITE_TOKEN_A_ADDRESS / VITE_TOKEN_B_ADDRESS
- VITE_TOKEN_C_ADDRESS / VITE_TOKEN_D_ADDRESS

Admin gating:
- VITE_ADMIN_ADDRESS (optional; if missing, admin mode may be broadly available)

11.2 Foundry deployment (shadowpool-hook)
- PRIVATE_KEY must be provided locally for broadcasting (never commit).
- Use Arbitrum Sepolia RPC URL for deployment.

11.3 iApp deployment/run (shadowpool-iapp)
- iapp CLI + docker required for build/test.
- iapp.config.json contains sensitive info; never commit.

12) Deployment and operations runbook (MVP)
12.1 On-chain deployment
Primary deploy script:
- shadowpool-hook/script/DeployShadowPool.s.sol
It deploys:
- PoolManager
- PoolSwapTest
- PoolModifyLiquidityTest
- ShadowPoolRootRegistry
- IntentRegistry (namespace + schedule)
- MockERC20 tokens (TKA/TKB) and seeds liquidity
- ShadowPoolHook (create2-mined address with BEFORE_SWAP + AFTER_SWAP permissions)

Important operational steps:
- Ensure teeSigner is set to the intended signer address (script defaults to deployer; can be changed via setTeeSigner).
- Ensure the swap execution harness address is configured in the frontend:
  - the UI expects VITE_POOL_SWAP_TEST_ADDRESS (PoolSwapTest) for demo execution.

12.2 iExec operational requirements
- AppOrder requirement:
  - The iApp must have an active AppOrder on the configured iExec chain or matching fails with “No App order found...”.
  - shadowpool-iapp can publish an AppOrder when run with PUBLISH_APPORDER=1 (owner wallet must have funds and be on the chosen chain).
- TEE tags:
  - Orders must support TEE (tee + scone).
- Fees/timeouts:
  - Bulk matching waits up to VITE_IEXEC_MATCH_TIMEOUT_MS (default 15 minutes).

13) Testing and QA gates (MVP)
13.1 Smart contracts (shadowpool-hook)
Run:
- forge build
- forge test

Must pass tests covering:
- IntentRegistry round enforcement (accept during intake, reject wrong roundId, reject after intake window)
- ShadowPoolRootRegistry root posting + matcher semantics
- ShadowPoolHook proof verification + signature verification
- Replay protection (MatchAlreadyUsed / LeafAlreadyUsed)

13.2 Frontend (shadow-pool-terminal)
Run:
- npm run lint
- npm run test
- npm run build

13.3 iApp (shadowpool-iapp)
Run:
- iapp test (with mocked protected data and args)

14) Demo checklist (recording-ready)
Minimum demo sequence:
1) Show intent creation form (private fields visible only in UI).
2) Protect intent → show protectedDataAddress.
3) Grant access → show authorizedApp and authorizedUser used.
4) Submit intent → show IntentRegistered tx + event fields (no price/size).
5) Repeat for second trader (opposite side).
6) Run matching → show iExec task completion and produced merkleRoot + matches.
7) Post merkleRoot → show on-chain ShadowPoolRootRegistry state.
8) Execute a match → show hook payload, successful swap, and matchUsed=true.
9) Attempt replay → show revert (MatchAlreadyUsed).

15) Security and privacy requirements (MVP)
15.1 Confidentiality rules
- Never place limitPrice, amountBase, expiry, salt, or notes on-chain.
- Never log raw decrypted intent values from the iApp in production builds.
- Treat frontend VITE_* variables as public; do not store secrets there for production.

15.2 Key management rules
- Do not commit PRIVATE_KEY / iapp.config.json / signer keys to the repo.
- teeSigner private key must be controlled and protected; compromise allows forging matches.

15.3 Integrity rules
- Hook must be the enforcement point; do not allow bypass paths that skip the hook validation.
- Merkle tree construction rules must match across iApp, frontend proof builder, and hook verifier (sorted-pair hashing).
